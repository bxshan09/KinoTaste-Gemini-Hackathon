

// ==========================================
// FILE PATH: ./Untitled.swift
// ==========================================

//
//  Untitled.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/5.
//



// ==========================================
// FILE PATH: ./KinoTaste Watch AppTests/KinoTaste_Watch_Watch_AppTests.swift
// ==========================================

//
//  KinoTaste_Watch_Watch_AppTests.swift
//  KinoTaste Watch Watch AppTests
//
//  Created by Boxiang Shan on 2026/1/10.
//

import Testing
@testable import KinoTaste_Watch_Watch_App

struct KinoTaste_Watch_Watch_AppTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}


// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchMovieCard.swift
// ==========================================

// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchMovieCard.swift
// ==========================================

import SwiftUI
import SDWebImageSwiftUI

struct WatchMovieCard: View {
    let movie: Movie
    
    var body: some View {
        ZStack(alignment: .bottomLeading) {
            // 1. æµ·æŠ¥
            WebImage(url: movie.posterURL)
                .resizable()
                .indicator(.activity)
                .aspectRatio(contentMode: .fill)
                .frame(maxWidth: .infinity)
                .frame(height: 110)
                .clipped()
            
            // 2. æ¸å˜é®ç½©
            LinearGradient(
                colors: [.clear, .black.opacity(0.1), .black.opacity(0.8), .black],
                startPoint: .center,
                endPoint: .bottom
            )
            
            // 3. ä¿¡æ¯æ–‡å­—
            VStack(alignment: .leading, spacing: 1) {
                Text(movie.title)
                    .font(.system(size: 14, weight: .bold, design: .rounded))
                    .foregroundColor(.white)
                    .lineLimit(1)
                    .shadow(color: .black, radius: 2)
                
                HStack(spacing: 4) {
                    // è¯„åˆ†
                    if let score = movie.voteAverage, score > 0 {
                        Image(systemName: "star.fill")
                            .font(.system(size: 9))
                            .foregroundColor(.yellow)
                        Text(String(format: "%.1f", score))
                            .font(.system(size: 11, weight: .heavy))
                            .foregroundColor(.yellow)
                        
                        Text("Â·")
                            .foregroundColor(.white.opacity(0.5))
                    }
                    
                    // å¹´ä»½
                    Text(movie.year)
                        .font(.system(size: 10))
                        .foregroundColor(.white.opacity(0.9))
                    
                    // åœ°åŒº/è¯­è¨€ (ğŸŸ¢ æ ¸å¿ƒä¿®å¤éƒ¨åˆ†)
                    if let (isKey, text) = getLanguageDisplay() {
                        Text("Â·")
                            .foregroundColor(.white.opacity(0.5))
                        
                        if isKey {
                            // ğŸŸ¢ æƒ…å†µAï¼šå¦‚æœæ˜¯æ‰‹åŠ¨æ˜ å°„çš„ Key (å¦‚ "è‹±è¯­")ï¼Œå¼ºåˆ¶ç”¨ LocalizedStringKey åŒ…è£¹
                            // è¿™æ ·ç³»ç»Ÿæ‰ä¼šå» strings æ–‡ä»¶é‡ŒæŸ¥åˆ° "è‹±èª"
                            Text(LocalizedStringKey(text))
                                .font(.system(size: 10))
                                .foregroundColor(.white.opacity(0.9))
                        } else {
                            // ğŸŸ¢ æƒ…å†µBï¼šå¦‚æœæ˜¯ç³»ç»Ÿ Locale è¿”å›çš„ (å¦‚ "EspaÃ±ol")ï¼Œç›´æ¥æ˜¾ç¤º
                            Text(text)
                                .font(.system(size: 10))
                                .foregroundColor(.white.opacity(0.9))
                        }
                    }
                }
            }
            .padding(8)
            .padding(.bottom, 3)
        }
        .frame(height: 110)
        .clipShape(RoundedRectangle(cornerRadius: 12))
        .shadow(color: .black.opacity(0.3), radius: 4, y: 2)
    }
    
    // ğŸŸ¢ è¾…åŠ©å‡½æ•°ï¼šè¿”å› (æ˜¯å¦ä¸ºKey, æ–‡æœ¬å†…å®¹)
    private func getLanguageDisplay() -> (Bool, String)? {
        // 1. ä¼˜å…ˆæ˜¾ç¤ºåœ°åŒº (å¦‚ US, CN) -> ç³»ç»Ÿè‡ªåŠ¨ç¿»è¯‘
        if let countryCode = movie.originCountry?.first, !countryCode.isEmpty {
            let countryName = Locale.current.localizedString(forRegionCode: countryCode) ?? countryCode
            return (false, countryName)
        }
        
        // 2. æ˜¾ç¤ºè¯­è¨€
        if let langCode = movie.originalLanguage, !langCode.isEmpty {
            // æ‰‹åŠ¨æ˜ å°„è¡¨ (å¯¹åº” Localizable.strings ä¸­çš„ Keys)
            let manualMap: [String: String] = [
                "en": "è‹±è¯­", "ja": "æ—¥è¯­", "ko": "éŸ©è¯­", "zh": "åè¯­", "cn": "åè¯­",
                "fr": "æ³•è¯­", "de": "å¾·è¯­", "it": "æ„å¤§åˆ©è¯­", "es": "è¥¿è¯­",
                "ru": "ä¿„è¯­", "hi": "å°åœ°è¯­", "th": "æ³°è¯­",
                // ğŸ‘‡ æ–°å¢è¡¥å……
                                "pt": "è‘¡è¯­", "da": "ä¸¹éº¦è¯­", "sv": "ç‘å…¸è¯­",
                                "fa": "æ³¢æ–¯è¯­", "nl": "è·å…°è¯­", "pl": "æ³¢å…°è¯­"
            ]
            
            // å¦‚æœåœ¨æ˜ å°„è¡¨ä¸­ï¼Œè¿”å› (true, Key)
            if let keyName = manualMap[langCode.lowercased()] {
                return (true, keyName)
            }
            
            // å¦åˆ™ä½¿ç”¨ç³»ç»Ÿç¿»è¯‘ï¼Œè¿”å› (false, String)
            let sysLang = Locale.current.localizedString(forIdentifier: langCode) ?? langCode
            return (false, sysLang)
        }
        return nil
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchMovieDetailView.swift
// ==========================================

//
//  WatchMovieDetailView.swift
//  KinoTaste Watch App
//
//  Created by Boxiang Shan on 2026/1/10.
//

import SwiftUI
import SDWebImageSwiftUI

struct WatchMovieDetailView: View {
    @State private var movie: Movie
    @EnvironmentObject var viewModel: AppViewModel
    @Environment(\.dismiss) var dismiss
    
    @State private var isToWatch: Bool = false
    @State private var currentRating: AppViewModel.RatingType? = nil
    @State private var isIgnored: Bool = false
    
    @State private var cast: [Cast] = []
    @State private var crew: [Crew] = []
    
    init(movie: Movie) {
        _movie = State(initialValue: movie)
    }
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 10) {
                // 1. æµ·æŠ¥ (å«è¯„åˆ†ä¿¡æ¯)
                WatchMovieCard(movie: movie)
                
                // 2. æ—¶é•¿
                if !movie.durationString.isEmpty {
                    Text("ç‰‡é•¿: \(movie.durationString)")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .padding(.leading, 2)
                }
                
                // 3. æ“ä½œæ 
                HStack(spacing: 0) {
                    // å¾…çœ‹
                    IconButton(icon: isToWatch ? "bookmark.fill" : "bookmark", color: .blue, isSelected: isToWatch) {
                        toggleWatchlist()
                    }
                    Spacer()
                    // å–œæ¬¢ (çº¢å¿ƒ)
                    IconButton(icon: "heart.fill", color: .red, isSelected: currentRating == .like) { rate(.like) }
                    Spacer()
                    // ä¸€èˆ¬ (ğŸŸ¢ ä¿®å¤ï¼šæ”¹ä¸ºé€šç”¨ face.smilingï¼Œæ©™è‰²)
                    IconButton(icon: "face.smiling", color: .orange, isSelected: currentRating == .neutral) { rate(.neutral) }
                    Spacer()
                    // ä¸å–œ (ç°æ‰‹)
                    IconButton(icon: "hand.thumbsdown.fill", color: .gray, isSelected: currentRating == .dislike) { rate(.dislike) }
                    Spacer()
                    // Pass
                    IconButton(icon: "eye.slash.fill", color: .purple, isSelected: isIgnored) { rate(.notInterested) }
                }
                .padding(.vertical, 4)
                
                Divider()
                
                // 4. ç®€ä»‹
                VStack(alignment: .leading, spacing: 4) {
                    Text("å‰§æƒ…ç®€ä»‹").font(.caption).bold()
                    Text(movie.overview.isEmpty ? "æš‚æ— ç®€ä»‹" : movie.overview)
                        .font(.caption2).foregroundColor(.secondary)
                        .lineLimit(nil)
                }
                
                // 5. æ¼”èŒå‘˜
                if !crew.isEmpty {
                    Divider()
                    Text("å¹•åä¸»åˆ›").font(.caption).bold()
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(alignment: .top, spacing: 12) {
                            ForEach(crew) { person in
                                NavigationLink(destination: WatchPersonMoviesView(personId: person.id, name: person.name)) {
                                    PersonHeadshot(name: person.name, url: person.profileURL, role: person.job)
                                }
                                .buttonStyle(.plain)
                            }
                        }
                    }
                }
                
                if !cast.isEmpty {
                    Divider()
                    Text("ä¸»æ¼”").font(.caption).bold()
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(alignment: .top, spacing: 12) {
                            ForEach(cast.prefix(6)) { actor in
                                NavigationLink(destination: WatchPersonMoviesView(personId: actor.id, name: actor.name)) {
                                    PersonHeadshot(name: actor.name, url: actor.profileURL, role: actor.character)
                                }
                                .buttonStyle(.plain)
                            }
                        }
                    }
                }
            }
        }
        .onAppear {
            checkStatus()
            loadCredits()
        }
    }
    
    // MARK: - é€»è¾‘
    private func rate(_ type: AppViewModel.RatingType) {
        withAnimation {
            if (type == .notInterested && isIgnored) || (currentRating == type) {
                viewModel.undoRating(for: movie)
                currentRating = nil
                isIgnored = false
            } else {
                viewModel.rateMovie(movie: movie, type: type)
                dismiss() // è‡ªåŠ¨è¿”å›
            }
        }
    }
    
    private func toggleWatchlist() {
        if isToWatch { viewModel.deleteFromWatchlist(movie) }
        else { viewModel.rateMovie(movie: movie, type: .addToWatch) }
        isToWatch.toggle()
    }
    
    private func checkStatus() {
        self.isToWatch = viewModel.isMovieToWatch(movie.id)
        self.currentRating = viewModel.checkRating(for: movie.id)
        if let rating = currentRating, rating == .notInterested {
            isIgnored = true
            currentRating = nil
        }
    }
    
    private func loadCredits() {
        Task {
            do {
                let credits = try await TMDBService.shared.fetchCredits(movieId: movie.id)
                self.cast = credits.cast
                var filtered: [Crew] = []
                var seen = Set<Int>()
                let jobMap = ["Director": "å¯¼æ¼”", "Screenplay": "ç¼–å‰§", "Writer": "ç¼–å‰§", "Director of Photography": "æ‘„å½±", "Editor": "å‰ªè¾‘"]
                for p in credits.crew {
                    if let cnJob = jobMap[p.job], !seen.contains(p.id) {
                        let newPerson = Crew(id: p.id, name: p.name, originalName: p.originalName, job: cnJob, profilePath: p.profilePath)
                        filtered.append(newPerson)
                        seen.insert(p.id)
                    }
                }
                let priority = ["å¯¼æ¼”":0, "ç¼–å‰§":1, "æ‘„å½±":2, "å‰ªè¾‘":3]
                self.crew = filtered.sorted { (priority[$0.job] ?? 99) < (priority[$1.job] ?? 99) }.prefix(6).map{$0}
            } catch {}
        }
    }
}

// è¾…åŠ©ç»„ä»¶
struct IconButton: View {
    let icon: String
    let color: Color
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            Image(systemName: icon)
                .font(.title3)
                .frame(width: 32, height: 32)
                .background(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
                .foregroundColor(isSelected ? color : .gray)
                .clipShape(Circle())
                .overlay(Circle().stroke(isSelected ? color : Color.clear, lineWidth: 1))
        }
        .buttonStyle(.plain)
    }
}

struct PersonHeadshot: View {
    let name: String
    let url: URL?
    let role: String
    var body: some View {
        VStack {
            WebImage(url: url).resizable().scaledToFill().frame(width: 44, height: 44).background(Color.gray.opacity(0.3)).clipShape(Circle())
            Text(name).font(.system(size: 9)).lineLimit(1).frame(width: 50)
            
            // ğŸŸ¢ ä¿®å¤ï¼šå¼ºåˆ¶è½¬æ¢ä¸º LocalizedStringKeyï¼Œå¦åˆ™"å¯¼æ¼”"æ— æ³•å˜ä¸º"å°æ¼”"
            Text(LocalizedStringKey(role))
                .font(.system(size: 8))
                .foregroundColor(.secondary)
                .lineLimit(1)
                .frame(width: 50)
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchRecommendationView.swift
// ==========================================

// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchRecommendationView.swift
// ==========================================

import SwiftUI
import SDWebImageSwiftUI

struct WatchRecommendationView: View {
    @EnvironmentObject var viewModel: AppViewModel
    @Binding var navPath: NavigationPath
    
    var body: some View {
        NavigationStack(path: $navPath) {
            ZStack {
                if viewModel.isLoading && viewModel.recommendedMovies.isEmpty {
                    ProgressView()
                } else if viewModel.recommendedMovies.isEmpty {
                    VStack(spacing: 10) {
                        Image(systemName: "film").font(.largeTitle)
                        Text("æš‚æ— æ¨è").foregroundColor(.secondary)
                        Button("åˆ·æ–°") { Task { await viewModel.refreshRecommendations(reset: true) } }
                    }
                } else {
                    ScrollViewReader { proxy in
                        ScrollView {
                            EmptyView().id("TOP_ANCHOR")
                            
                            VStack(spacing: 15) {
                                // 1. é¡¶éƒ¨æç¤ºä¼˜åŒ–
                                if let cat = viewModel.selectedCategory {
                                    Text(cat.name).font(.caption).foregroundColor(.blue)
                                } else {
                                    // ğŸŸ¢ ä¼˜åŒ–1ï¼šä¿®æ­£å‰¯æ ‡é¢˜ä¸ºâ€œçŒœä½ å–œæ¬¢â€
                                    Text("çŒœä½ å–œæ¬¢").font(.caption).foregroundColor(.secondary)
                                }
                                
                                ForEach(viewModel.recommendedMovies) { movie in
                                    // ğŸŸ¢ ä¼˜åŒ–2ï¼šä¿®å¤ç‚¹å‡»ä¸å‡†ç¡®é—®é¢˜
                                    NavigationLink(value: movie) {
                                        WatchMovieCard(movie: movie)
                                            // å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶å®šä¹‰ç‚¹å‡»çƒ­åŒºå½¢çŠ¶ï¼Œé˜²æ­¢ NavigationLink åœ¨ ScrollView ä¸­çƒ­åŒºæ¼‚ç§»
                                            .contentShape(Rectangle())
                                    }
                                    .buttonStyle(.plain)
                                }
                                
                                Button {
                                    Task { await viewModel.refreshRecommendations(reset: false) }
                                } label: {
                                    if viewModel.isLoading {
                                        ProgressView().scaleEffect(0.5)
                                    } else {
                                        Text("åŠ è½½æ›´å¤š")
                                    }
                                }
                                .padding(.vertical)
                            }
                            .padding(.top, 4)
                        }
                        .onChange(of: viewModel.selectedCategory) { _, _ in
                            withAnimation { proxy.scrollTo("TOP_ANCHOR", anchor: .top) }
                        }
                    }
                }
            }
            .navigationTitle("æ¨è")
            .navigationDestination(for: Movie.self) { movie in
                WatchMovieDetailView(movie: movie)
            }
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchSettingsView.swift
// ==========================================

//
//  WatchSettingsView.swift
//  KinoTaste Watch App
//
//  Created by Boxiang Shan on 2026/1/10.
//

import SwiftUI
import SDWebImageSwiftUI

struct WatchSettingsView: View {
    // ğŸŸ¢ çŠ¶æ€å˜é‡ï¼šå…ˆç¡®è®¤ï¼Œå†æç¤ºæˆåŠŸ
    @State private var showClearConfirmation = false
    @State private var showClearSuccess = false
    
    @State private var showResetAlert = false
    @EnvironmentObject var viewModel: AppViewModel
    
    var body: some View {
        NavigationStack {
            List {
                Section {
                    Button {
                        // 1. è§¦å‘ç¡®è®¤å¼¹çª—
                        showClearConfirmation = true
                    } label: {
                        Label("æ¸…é™¤å›¾ç‰‡ç¼“å­˜", systemImage: "trash")
                    }
                    
                    Button {
                        viewModel.requestReview()
                    } label: {
                        Label("ç»™ä¸ªå¥½è¯„", systemImage: "star.bubble")
                    }
                } header: {
                    Text("å­˜å‚¨ä¸è¯„ä»·")
                }
                
                Section {
                    Button(role: .destructive) {
                        showResetAlert = true
                    } label: {
                        Label("é‡ç½®å£å‘³æ•°æ®", systemImage: "arrow.counterclockwise")
                            .foregroundColor(.red)
                    }
                }
                
                Section {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("KinoTaste for Watch")
                            .font(.headline)
                        
                        // ğŸŸ¢ ä¿®å¤ï¼šæ‹†åˆ†æ–‡æœ¬ï¼Œç¡®ä¿ "Version" èƒ½åŒ¹é…åˆ° Strings æ–‡ä»¶é‡Œçš„ Key
                        HStack(spacing: 4) {
                            Text(LocalizedStringKey("Version")) // è¿™é‡Œä¼šæ˜¾ç¤º "ç‰ˆæœ¬"
                            Text(Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0")
                        }
                        .font(.caption)
                        .foregroundColor(.secondary)
                        
                        Divider().padding(.vertical, 4)
                        
                        HStack(spacing: 6) {
                            Image(systemName: "database")
                            Text(LocalizedStringKey("Data provided by TMDB"))
                        }
                        .font(.system(size: 10))
                        .foregroundColor(.blue)
                    }
                    .padding(.vertical, 4)
                }
            }
            .navigationTitle("è®¾ç½®")
            // ğŸŸ¢ 1. ç¡®è®¤å¼¹çª—
            .alert("ç¡®è®¤æ¸…é™¤ï¼Ÿ", isPresented: $showClearConfirmation) {
                Button("å–æ¶ˆ", role: .cancel) { }
                Button("ç¡®å®š", role: .destructive) {
                    SDImageCache.shared.clearMemory()
                    SDImageCache.shared.clearDisk()
                    // å»¶è¿Ÿæ˜¾ç¤ºæˆåŠŸæç¤º
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                        showClearSuccess = true
                    }
                }
            } message: {
                Text("å°†åˆ é™¤æ‰€æœ‰å·²ä¸‹è½½çš„æµ·æŠ¥å›¾ç‰‡ã€‚")
            }
            // ğŸŸ¢ 2. æˆåŠŸæç¤º
            .alert("å·²æ¸…é™¤", isPresented: $showClearSuccess) {
                Button("å¥½") { }
            } message: {
                Text("ç©ºé—´å·²é‡Šæ”¾ã€‚")
            }
            // é‡ç½®å¼¹çª—
            .alert("ç¡®å®šé‡ç½®ï¼Ÿ", isPresented: $showResetAlert) {
                Button("å–æ¶ˆ", role: .cancel) { }
                Button("ç¡®å®š", role: .destructive) {
                    viewModel.resetApp()
                }
            } message: {
                Text("æ‰€æœ‰æ•°æ®å°†è¢«æ¸…ç©ºä¸”æ— æ³•æ¢å¤ã€‚")
            }
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchPersonMoviesView.swift
// ==========================================

//
//  WatchPersonMoviesView.swift
//  KinoTaste Watch App
//
//  Created by Boxiang Shan on 2026/1/10.
//

import SwiftUI
import SDWebImageSwiftUI

struct WatchPersonMoviesView: View {
    let personId: Int
    let name: String
    
    @StateObject private var viewModel = AppViewModel()
    @State private var movies: [Movie] = []
    @State private var isLoading = true
    
    var body: some View {
        Group {
            if isLoading {
                ProgressView()
            } else if movies.isEmpty {
                Text("æš‚æ— ç›¸å…³ä½œå“")
                    .foregroundColor(.secondary)
            } else {
                // ğŸŸ¢ åˆ—è¡¨è§†å›¾ï¼Œä¸ä½¿ç”¨å¤§æµ·æŠ¥
                List(movies) { movie in
                    NavigationLink(destination: WatchMovieDetailView(movie: movie)) {
                        VStack(alignment: .leading, spacing: 2) {
                            Text(movie.title)
                                .font(.headline)
                                .lineLimit(1)
                            
                            HStack {
                                Text(movie.year)
                                    .foregroundColor(.secondary)
                                
                                if let role = movie.recommendationReason, !role.isEmpty {
                                    Text("Â· \(role)")
                                        .foregroundColor(.blue)
                                }
                            }
                            .font(.caption2)
                        }
                        .padding(.vertical, 2)
                    }
                }
            }
        }
        .navigationTitle(name)
        .onAppear {
            loadWorks()
        }
    }
    
    private func loadWorks() {
        Task {
            do {
                let works = try await viewModel.fetchPersonWorks(personId: personId)
                self.movies = works
            } catch {}
            self.isLoading = false
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchOnboardingView.swift
// ==========================================

// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchOnboardingView.swift
// ==========================================

import SwiftUI
import SDWebImageSwiftUI
import WatchKit

struct WatchOnboardingView: View {
    @EnvironmentObject var viewModel: AppViewModel
    @State private var interactionCount: Int = 0
    private let minTarget = 10
    
    // æ§åˆ¶ç®€ä»‹æ˜¾ç¤ºçš„çŠ¶æ€
    @State private var showOverview: Bool = false
    
    var body: some View {
        NavigationStack {
            ZStack(alignment: .top) {
                // 1. ä¸»è¦å†…å®¹åŒºåŸŸ
                VStack(spacing: 0) {
                    // é¡¶éƒ¨å ä½ (ä¸ºæ‚¬æµ®æŒ‰é’®ç•™ç©ºé—´)
                    if interactionCount >= minTarget {
                        Spacer().frame(height: 45)
                    } else {
                        // è¿›åº¦æç¤º
                        Text("\(interactionCount) / \(minTarget)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                            .padding(.top, 4)
                            .frame(height: 25)
                    }
                    
                    Spacer() // å¼¹æ€§ç©ºé—´ï¼Œè®©å¡ç‰‡å±…ä¸­åä¸Š
                    
                    // --- ç”µå½±å¡ç‰‡åŒºåŸŸ ---
                    if let movie = viewModel.onboardingMovies.first {
                        VStack(spacing: 12) {
                            // å¡ç‰‡ä¸»ä½“
                            DraggableWatchCard(
                                movie: movie,
                                showOverview: $showOverview,
                                onRate: { type in handleRate(movie, type: type) }
                            )
                            .id(movie.id) // ç¡®ä¿è§†å›¾åˆ·æ–°
                            .zIndex(1)    // å±‚çº§ä¸º 1
                            
                            // åº•éƒ¨è¯„ä»·æŒ‰é’®ç»„
                            HStack(spacing: 2) { // å‡å°é—´è·é˜²æ­¢æº¢å‡º
                                OnboardingIconButton(icon: "bookmark", color: .blue) { handleRate(movie, type: .addToWatch) }
                                Spacer()
                                OnboardingIconButton(icon: "heart.fill", color: .red) { handleRate(movie, type: .like) }
                                Spacer()
                                OnboardingIconButton(icon: "face.smiling", color: .orange) { handleRate(movie, type: .neutral) }
                                Spacer()
                                OnboardingIconButton(icon: "hand.thumbsdown.fill", color: .gray) { handleRate(movie, type: .dislike) }
                                Spacer()
                                OnboardingIconButton(icon: "eye.slash.fill", color: .purple) { handleRate(movie, type: .notInterested) }
                            }
                            .padding(.horizontal, 4)
                            .padding(.bottom, 6)
                            .zIndex(2) // ğŸŸ¢ å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶æŒ‰é’®å±‚çº§é«˜äºå¡ç‰‡ï¼Œé˜²æ­¢è¢«é®æŒ¡
                        }
                    } else {
                        VStack(spacing: 10) {
                            ProgressView()
                            Text("å‡†å¤‡ç‰‡å•...").font(.caption2).foregroundColor(.secondary)
                        }
                        .frame(maxHeight: .infinity)
                    }
                    
                    Spacer() // åº•éƒ¨å¼¹æ€§ç©ºé—´
                }
                
                // 2. â€œè¿›å…¥é¦–é¡µâ€æ‚¬æµ®æŒ‰é’® (æœ€é¡¶å±‚)
                if interactionCount >= minTarget {
                    Button {
                        WKInterfaceDevice.current().play(.success)
                        withAnimation(.easeInOut) {
                            viewModel.completeOnboardingEarly()
                        }
                    } label: {
                        Text("è¿›å…¥é¦–é¡µ \(interactionCount)")
                            .font(.system(size: 14, weight: .bold))
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 8)
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.blue)
                    .padding(.horizontal, 8)
                    .padding(.top, 2)
                    .zIndex(999) // ç¡®ä¿æ‚¬æµ®åœ¨ä¸€åˆ‡ä¹‹ä¸Š
                }
            }
            .navigationTitle("å®šåˆ¶å£å‘³")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
    
    private func handleRate(_ movie: Movie, type: AppViewModel.RatingType) {
        // å¢åŠ è§¦è§‰åé¦ˆï¼Œè®©ç”¨æˆ·çŸ¥é“ç‚¹å‡»ç”Ÿæ•ˆäº†
        WKInterfaceDevice.current().play(.click)
        
        withAnimation {
            showOverview = false
            viewModel.rateMovie(movie: movie, type: type)
            if let index = viewModel.onboardingMovies.firstIndex(where: { $0.id == movie.id }) {
                viewModel.onboardingMovies.remove(at: index)
            }
            interactionCount += 1
        }
    }
}

// ğŸŸ¢ æ‹–æ‹½å¡ç‰‡ç»„ä»¶
struct DraggableWatchCard: View {
    let movie: Movie
    @Binding var showOverview: Bool
    let onRate: (AppViewModel.RatingType) -> Void
    
    @State private var offset: CGSize = .zero
    @State private var isDragging: Bool = false
    
    var body: some View {
        ZStack {
            if showOverview {
                // --- èƒŒé¢ï¼šå‰§æƒ…ç®€ä»‹ ---
                ZStack {
                    Color.black.opacity(0.9).cornerRadius(12)
                    ScrollView {
                        VStack(alignment: .leading, spacing: 6) {
                            HStack {
                                Image(systemName: "info.circle.fill").font(.caption)
                                Text("å‰§æƒ…ç®€ä»‹").font(.caption.bold())
                                Spacer()
                            }
                            .foregroundColor(.blue)
                            .padding(.bottom, 2)
                            
                            Text(movie.overview.isEmpty ? "æš‚æ— ç®€ä»‹" : movie.overview)
                                .font(.system(size: 13))
                                .foregroundColor(.white.opacity(0.9))
                                .lineSpacing(2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                            
                            Spacer(minLength: 20)
                            Text("ç‚¹å‡»å…³é—­").font(.system(size: 10)).foregroundColor(.gray).frame(maxWidth: .infinity, alignment: .center)
                        }
                        .padding(12)
                    }
                }
                .onTapGesture { withAnimation(.spring()) { showOverview = false } }
                
            } else {
                // --- æ­£é¢ï¼šæµ·æŠ¥ ---
                WatchMovieCard(movie: movie)
                    .overlay(
                        VStack {
                            Spacer()
                            HStack(spacing: 4) {
                                Image(systemName: "hand.tap")
                                Text("é•¿æŒ‰çœ‹ç®€ä»‹")
                            }
                            .font(.system(size: 9))
                            .foregroundColor(.white.opacity(0.7))
                            .padding(.bottom, 6)
                            .shadow(color: .black, radius: 2)
                        }
                    )
                    // å·¦æ»‘/å³æ»‘å›¾æ ‡æŒ‡ç¤º
                    .overlay(
                        ZStack {
                            if offset.width < -30 {
                                Image(systemName: "eye.slash.fill").font(.largeTitle).foregroundColor(.purple)
                            } else if offset.width > 30 {
                                Image(systemName: "heart.fill").font(.largeTitle).foregroundColor(.red)
                            }
                        }
                    )
                    .onLongPressGesture(minimumDuration: 0.3) {
                        WKInterfaceDevice.current().play(.click)
                        withAnimation(.spring()) { showOverview = true }
                    }
            }
        }
        .frame(height: 110) // å›ºå®šé«˜åº¦
        .offset(offset)
        .rotationEffect(.degrees(Double(offset.width / 20)))
        .scaleEffect(isDragging ? 1.05 : 1.0)
        .gesture(
            DragGesture()
                .onChanged { gesture in
                    if !showOverview {
                        withAnimation(.interactiveSpring()) {
                            offset = gesture.translation
                            isDragging = true
                        }
                    }
                }
                .onEnded { _ in
                    if !showOverview {
                        handleSwipeEnd()
                    }
                }
        )
    }
    
    private func handleSwipeEnd() {
        let threshold: CGFloat = 80
        if offset.width < -threshold {
            swipeAndRate(.notInterested, x: -500)
        } else if offset.width > threshold {
            swipeAndRate(.like, x: 500)
        } else {
            withAnimation(.spring()) {
                offset = .zero
                isDragging = false
            }
        }
    }
    
    private func swipeAndRate(_ type: AppViewModel.RatingType, x: CGFloat) {
        WKInterfaceDevice.current().play(.click)
        withAnimation(.easeIn(duration: 0.2)) {
            offset = CGSize(width: x, height: 0)
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            onRate(type)
            offset = .zero
            isDragging = false
        }
    }
}

// ğŸŸ¢ æŒ‰é’®ç»„ä»¶ä¼˜åŒ–
struct OnboardingIconButton: View {
    let icon: String
    let color: Color
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            Image(systemName: icon)
                .font(.title3)
                .frame(width: 34, height: 34)
                .background(color.opacity(0.15))
                .foregroundColor(color)
                .clipShape(Circle())
                // ğŸŸ¢ å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶æ•´ä¸ªçŸ©å½¢åŒºåŸŸéƒ½å¯ç‚¹å‡»ï¼Œè§£å†³ç‚¹å‡»è¾¹ç¼˜æ— æ•ˆçš„é—®é¢˜
                .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch/WatchContentView.swift
// ==========================================

//
//  WatchContentView.swift
//  KinoTaste Watch App
//
//  Created by Boxiang Shan on 2026/1/10.
//

import SwiftUI
import SwiftData
import SDWebImageSwiftUI

struct WatchContentView: View {
    @StateObject var viewModel = AppViewModel()
    @Environment(\.modelContext) var modelContext
    @State private var navPath = NavigationPath()
    @State private var selectedTab = 0
    
    var body: some View {
        ZStack {
            if viewModel.showSplash {
                WatchSplashView().transition(.opacity)
            } else if viewModel.appState == .onboarding {
                WatchOnboardingView().environmentObject(viewModel).transition(.move(edge: .trailing))
            } else {
                WatchMainTabView(selectedTab: $selectedTab, navPath: $navPath)
                    .environmentObject(viewModel)
                    .transition(.opacity)
            }
        }
        .animation(.easeInOut, value: viewModel.showSplash)
        .animation(.easeInOut, value: viewModel.appState)
        .onAppear { viewModel.setContext(modelContext) }
    }
}

// Launch
struct WatchSplashView: View {
    var body: some View {
        ZStack {
            // åº•å±‚ï¼šå…¨å±æµ·æŠ¥
            Image("LaunchImage")
                .resizable()
                .aspectRatio(contentMode: .fill)
                .ignoresSafeArea()
                .opacity(0.6) // ç¨å¾®å‹æš—ä¸€ç‚¹ï¼Œå› ä¸ºæ‰‹è¡¨ä¸Šæ–‡å­—è¦æ›´æ¸…æ™°
            
            // ä¸Šå±‚ï¼šæ–‡å­—
            VStack(spacing: 8) {
                Text("ä»Šå¤©çœ‹ä»€ä¹ˆ")
                    .font(.system(size: 20, weight: .heavy, design: .serif))
                    .foregroundColor(.white)
                    .shadow(radius: 2)
                
                Text("å‘ç°ä½ çš„ä¸‹ä¸€éƒ¨ç”µå½±")
                    .font(.system(size: 11))
                    .fontWeight(.bold)
                    .foregroundColor(.white.opacity(0.8))
            }
        }
    }
}

// Main Tab
struct WatchMainTabView: View {
    @EnvironmentObject var viewModel: AppViewModel
    @Binding var selectedTab: Int
    @Binding var navPath: NavigationPath
    
    var body: some View {
        TabView(selection: $selectedTab) {
            WatchRecommendationView(navPath: $navPath).tag(0)
            WatchCategoryListView(selectedTab: $selectedTab, navPath: $navPath).tag(1)
            WatchRatedListView().tag(2)
            WatchWatchlistView().tag(3)
            WatchSettingsView().tag(4)
        }
        .tabViewStyle(.page)
    }
}

// ğŸŸ¢ ä¿®æ”¹åçš„åˆ†ç±»åˆ—è¡¨è§†å›¾
struct WatchCategoryListView: View {
    @EnvironmentObject var viewModel: AppViewModel
    @Binding var selectedTab: Int
    @Binding var navPath: NavigationPath
    
    var body: some View {
        NavigationStack {
            List {
                // 1. çŒœä½ å–œæ¬¢ (é‡ç½®åˆ†ç±»)
                Button {
                    resetAndNavigate(to: nil)
                } label: {
                    HStack {
                        Image(systemName: "sparkles").foregroundColor(.yellow)
                        // è¿™é‡Œçš„ "çŒœä½ å–œæ¬¢" æ˜¯å­—é¢é‡ï¼ŒSwiftUI ä¼šè‡ªåŠ¨ç¿»è¯‘
                        Text("çŒœä½ å–œæ¬¢")
                        Spacer()
                        if viewModel.selectedCategory == nil {
                            Image(systemName: "checkmark").font(.caption).foregroundColor(.blue)
                        }
                    }
                }
                
                // 2. åˆ†ç±»åˆ—è¡¨
                ForEach(viewModel.sortedCategories) { category in
                    Button {
                        resetAndNavigate(to: category)
                    } label: {
                        HStack {
                            // ğŸŸ¢ å…³é”®ä¿®å¤ï¼š
                            // category.name æ˜¯å˜é‡ï¼Œå¿…é¡»ç”¨ LocalizedStringKey åŒ…è£¹æ‰èƒ½è§¦å‘æœ¬åœ°åŒ–æŸ¥æ‰¾
                            Text(LocalizedStringKey(category.name))
                            
                            Spacer()
                            if viewModel.selectedCategory == category {
                                Image(systemName: "checkmark").font(.caption).foregroundColor(.blue)
                            }
                        }
                    }
                }
            }
            .navigationTitle("åˆ†ç±»")
        }
    }
    
    private func resetAndNavigate(to category: CategoryItem?) {
        navPath = NavigationPath()
        withAnimation {
            selectedTab = 0
        }
        Task {
            await viewModel.changeCategory(to: category)
        }
    }
}
struct WatchRatedListView: View {
    @EnvironmentObject var viewModel: AppViewModel
    @Query(sort: \SavedMovie.interactionDate, order: .reverse) var allRatedMovies: [SavedMovie]
    @State private var filterMode: Int = 0
    
    var filteredMovies: [SavedMovie] {
        filterMode == 1 ? allRatedMovies.filter { $0.isLiked } : allRatedMovies.filter { $0.isLiked || $0.isNeutral || $0.isDisliked }
    }
    
    var body: some View {
        NavigationStack {
            VStack {
                HStack(spacing: 8) {
                    Button { withAnimation { filterMode = 0 } } label: {
                        Text("å…¨éƒ¨").font(.caption2).frame(maxWidth: .infinity).padding(.vertical, 6)
                            .background(filterMode == 0 ? Color.blue : Color.gray.opacity(0.3)).cornerRadius(8)
                    }.buttonStyle(.plain)
                    Button { withAnimation { filterMode = 1 } } label: {
                        Text("å–œæ¬¢").font(.caption2).frame(maxWidth: .infinity).padding(.vertical, 6)
                            .background(filterMode == 1 ? Color.orange : Color.gray.opacity(0.3)).cornerRadius(8)
                    }.buttonStyle(.plain)
                }.padding(.horizontal).padding(.bottom, 5)
                
                if filteredMovies.isEmpty {
                    Spacer(); Text("æš‚æ— è®°å½•").foregroundColor(.secondary); Spacer()
                } else {
                    List {
                        ForEach(filteredMovies) { savedMovie in
                            NavigationLink(destination: WatchMovieDetailView(movie: savedMovie.toMovie)) {
                                HStack {
                                    if savedMovie.isLiked { Image(systemName: "heart.fill").foregroundColor(.red).font(.caption2) }
                                    else if savedMovie.isDisliked { Image(systemName: "hand.thumbsdown.fill").foregroundColor(.gray).font(.caption2) }
                                    else {
                                        // ğŸŸ¢ ä¿®å¤ï¼šåŒæ­¥ä¸º face.smiling (æ©™è‰²)
                                        Image(systemName: "face.smiling").foregroundColor(.orange).font(.caption2)
                                    }
                                    Text(savedMovie.title).lineLimit(1)
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle("å·²è¯„ä»·")
        }
    }
}

struct WatchWatchlistView: View {
    @EnvironmentObject var viewModel: AppViewModel
    var body: some View {
        NavigationStack {
            VStack {
                Label("å¾…çœ‹æ¸…å•", systemImage: "bookmark.fill")
                    .font(.headline)
                    .padding(.bottom, 5)
                
                if viewModel.toWatchList.isEmpty {
                    Spacer()
                    VStack { Text("æš‚æ— å¾…çœ‹").foregroundColor(.secondary) }
                    Spacer()
                } else {
                    List {
                        ForEach(viewModel.toWatchList) { movie in
                            NavigationLink(destination: WatchMovieDetailView(movie: movie)) {
                                Text(movie.title).lineLimit(2)
                            }
                        }
                    }
                }
            }
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch/KinoTaste_WatchApp.swift
// ==========================================

//
//  KinoTaste_WatchApp.swift
//  KinoTaste Watch App
//
//  Created by Boxiang Shan on 2026/1/10.
//

import SwiftUI
import SwiftData
import SDWebImageSwiftUI

@main
struct KinoTaste_Watch_AppApp: App {
    // å…±ç”¨ AppViewModel
    @StateObject var viewModel = AppViewModel()
    
    // æ³¨å…¥ SwiftData å®¹å™¨
    var sharedModelContainer: ModelContainer = {
        let schema = Schema([
            SavedMovie.self,
        ])
        let modelConfiguration = ModelConfiguration(schema: schema, isStoredInMemoryOnly: false)

        do {
            return try ModelContainer(for: schema, configurations: [modelConfiguration])
        } catch {
            fatalError("Could not create ModelContainer: \(error)")
        }
    }()
    
    // é…ç½® SDWebImage (è·Ÿ iOS ç«¯ä¿æŒä¸€è‡´çš„ç¼“å­˜ç­–ç•¥)
    init() {
        let cache = SDImageCache.shared
        cache.config.maxDiskSize = 50 * 1024 * 1024 // æ‰‹è¡¨å­˜å‚¨å°ï¼Œæ”¹å°ä¸€ç‚¹ (50MB)
        cache.config.maxMemoryCost = 10 * 1024 * 1024
        cache.config.diskCacheExpireType = .accessDate
        cache.config.maxDiskAge = 60 * 60 * 24 * 7
    }

    var body: some Scene {
        WindowGroup {
            ZStack {
                // ğŸŸ¢ 1. éšç§æ‹¦æˆªå±‚ (Watch ç‰ˆ)
                if !viewModel.hasAgreedPrivacy {
                    WatchPrivacyView(viewModel: viewModel)
                        .zIndex(2)
                } else {
                    // ğŸŸ¢ 2. ä¸»æµç¨‹
                    WatchContentView()
                        .environmentObject(viewModel)
                        // ç¡®ä¿ Splash è¦†ç›–åœ¨ Content ä¹‹ä¸Š
                        .overlay(
                            Group {
                                if viewModel.showSplash {
                                    WatchSplashView()
                                        .transition(.opacity)
                                }
                            }
                        )
                }
            }
            .animation(.easeInOut, value: viewModel.hasAgreedPrivacy)
            .animation(.easeInOut, value: viewModel.showSplash)
            .background(WatchContextSetter(viewModel: viewModel))
            .modelContainer(sharedModelContainer)
        }
    }
}

// è¾…åŠ©ï¼šæ³¨å…¥ Context
struct WatchContextSetter: View {
    @Environment(\.modelContext) var context
    var viewModel: AppViewModel
    
    var body: some View {
        Color.clear
            .onAppear {
                viewModel.setContext(context)
            }
    }
}

// MARK: - ğŸŸ¢ æ–°å¢ï¼šæ‰‹è¡¨ä¸“ç”¨éšç§é¡µ
struct WatchPrivacyView: View {
    @ObservedObject var viewModel: AppViewModel
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                Image(systemName: "hand.raised.fill")
                    .font(.title2)
                    .foregroundColor(.blue)
                    .padding(.top, 10)
                
                Text("æ¬¢è¿ä½¿ç”¨")
                    .font(.headline)
                
                Text("è¯·é˜…è¯»å¹¶åŒæ„éšç§æ”¿ç­–ä»¥ç»§ç»­ä½¿ç”¨ã€‚æˆ‘ä»¬ä»…æ”¶é›†å¿…è¦çš„è§‚å½±åå¥½ç”¨äºæ¨èã€‚")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                
                // æ‰‹è¡¨ä¸Šå¾ˆéš¾çœ‹ç½‘é¡µï¼Œé€šå¸¸åªæä¾›æ–‡å­—æç¤ºï¼Œæˆ–è®©ç”¨æˆ·åœ¨ iPhone ä¸Šçœ‹
                // ä½†ä¸ºäº†åˆè§„ï¼Œæˆ‘ä»¬è¿˜æ˜¯æ”¾ä¸€ä¸ªæŒ‰é’®å½¢å¼
                Link("é˜…è¯»éšç§æ”¿ç­–", destination: URL(string: "https://api.kinotaste.online/privacy.html")!)
                    .font(.caption2)
                    .foregroundColor(.blue)
                
                Button(action: {
                    withAnimation {
                        viewModel.agreePrivacy()
                    }
                }) {
                    Text("åŒæ„å¹¶ç»§ç»­")
                        .font(.caption)
                        .fontWeight(.bold)
                }
                .tint(.blue)
                .padding(.top, 4)
                .padding(.bottom, 10)
            }
        }
        .background(Color.black)
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch AppUITests/KinoTaste_Watch_Watch_AppUITestsLaunchTests.swift
// ==========================================

//
//  KinoTaste_Watch_Watch_AppUITestsLaunchTests.swift
//  KinoTaste Watch Watch AppUITests
//
//  Created by Boxiang Shan on 2026/1/10.
//

import XCTest

final class KinoTaste_Watch_Watch_AppUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}


// ==========================================
// FILE PATH: ./KinoTaste Watch AppUITests/KinoTaste_Watch_Watch_AppUITests.swift
// ==========================================

//
//  KinoTaste_Watch_Watch_AppUITests.swift
//  KinoTaste Watch Watch AppUITests
//
//  Created by Boxiang Shan on 2026/1/10.
//

import XCTest

final class KinoTaste_Watch_Watch_AppUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests itâ€™s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTasteTests/KinoTasteTests.swift
// ==========================================

//
//  KinoTasteTests.swift
//  KinoTasteTests
//
//  Created by Boxiang Shan on 2026/1/4.
//

import Testing
@testable import KinoTaste

struct KinoTasteTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}


// ==========================================
// FILE PATH: ./KinoTaste/MovieDetailView.swift
// ==========================================

//
//  MovieDetailView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SDWebImageSwiftUI

struct PersonLinkCell: View {
    let personId: Int
    let name: String
    let imageURL: URL?
    let role: String
    
    var body: some View {
        let tempPerson = Person(id: personId, name: name, originalName: nil, knownForDepartment: nil, profilePath: nil, popularity: nil)
        
        NavigationLink(destination: DirectorMoviesView(director: tempPerson)) {
            VStack(spacing: 6) {
                WebImage(url: imageURL)
                    .resizable()
                    .indicator(.activity)
                    .scaledToFill()
                    .frame(width: 80, height: 80)
                    .background(Color.gray.opacity(0.3))
                    .clipShape(Circle())
                    .overlay(Circle().stroke(Color.gray.opacity(0.1), lineWidth: 1))
                
                VStack(spacing: 2) {
                    Text(name).font(.caption).fontWeight(.medium).foregroundColor(.primary).lineLimit(1).frame(width: 80)
                    Text(LocalizedStringKey(role)).font(.system(size: 10)).foregroundColor(.secondary).lineLimit(1).frame(width: 80)
                }
            }
        }
    }
}

struct CompanyMoviesView: View {
    let company: ProductionCompany
    @State private var movies: [Movie] = []
    @State private var isLoading = true
    
    var body: some View {
        VStack {
            if isLoading {
                ProgressView()
            } else if movies.isEmpty {
                Text("æš‚æ— æ•°æ®").foregroundColor(.secondary)
            } else {
                ScrollView {
                    LazyVStack(spacing: 16) {
                        ForEach(movies) { movie in
                            NavigationLink(destination: MovieDetailView(movie: movie)) {
                                MovieCardView(movie: movie, isDetailMode: .constant(true))
                                    .padding(.horizontal)
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                    .padding(.top)
                }
            }
        }
        .navigationTitle(company.name)
        .onAppear {
            Task {
                do {
                    let res = try await TMDBService.shared.fetchRecommendations(
                        includeGenres: [], excludeGenres: [],
                        withCompanies: String(company.id),
                        sortBy: "popularity.desc",
                        minVoteCount: 50,
                        page: 1
                    )
                    self.movies = res
                } catch {}
                self.isLoading = false
            }
        }
    }
}

struct LaurelBadge: View {
    var body: some View {
        HStack(spacing: 2) {
            Image(systemName: "laurel.leading")
            Text("Top Rated")
                .font(.system(size: 10, weight: .bold))
                .textCase(.uppercase)
            Image(systemName: "laurel.trailing")
        }
        .foregroundColor(.yellow)
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(Color.black.opacity(0.6))
        .cornerRadius(4)
        .overlay(RoundedRectangle(cornerRadius: 4).stroke(Color.yellow.opacity(0.5), lineWidth: 1))
    }
}

// ğŸŸ¢ æ–°å¢ï¼šå³ä¸‹è§’æ‚¬æµ®é¢„å‘ŠæŒ‰é’® (ä¸¥æ ¼ä¿ç•™äº†æ‚¨åŸæ¥çš„å›¾æ ‡å’Œæ–‡å­—)
struct PlayTrailerButton: View {
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                // ä¿æŒåŸæ¥çš„å›¾æ ‡
                Image(systemName: "play.tv.fill")
                    .font(.system(size: 14))
                // ä¿æŒåŸæ¥çš„æ–‡å­—
                Text("é¢„å‘Š")
                    .font(.system(size: 14, weight: .bold))
            }
            .foregroundColor(.white)
            .padding(.vertical, 8)
            .padding(.horizontal, 16)
            .background(.ultraThinMaterial) // æ¯›ç»ç’ƒèƒŒæ™¯
            .clipShape(Capsule())
            .overlay(
                Capsule()
                    .stroke(Color.white.opacity(0.3), lineWidth: 0.5)
            )
            .shadow(color: .black.opacity(0.3), radius: 4, x: 0, y: 2)
        }
    }
}

// è¾…åŠ©ç»„ä»¶ï¼šç»Ÿä¸€æ“ä½œæŒ‰é’®æ ·å¼
struct DetailActionButton: View {
    let icon: String
    let title: String
    let isActive: Bool
    let activeColor: Color
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.title3)
                Text(LocalizedStringKey(title))
                    .font(.caption2)
                    .fontWeight(.bold)
            }
            .frame(width: 60, height: 60)
            .background(isActive ? activeColor.opacity(0.15) : Color(UIColor.secondarySystemBackground))
            .foregroundColor(isActive ? activeColor : .secondary)
            .cornerRadius(12)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isActive ? activeColor.opacity(0.3) : Color.clear, lineWidth: 1)
            )
        }
    }
}

struct MovieDetailView: View {
    @State private var movie: Movie
    @State private var preservedGenres: String = ""
    var autoDismiss: Bool = false
    
    init(movie: Movie, autoDismiss: Bool = false) {
        _movie = State(initialValue: movie)
        _preservedGenres = State(initialValue: movie.genresString)
        self.autoDismiss = autoDismiss
    }
    
    @EnvironmentObject var viewModel: AppViewModel
    @Environment(\.presentationMode) var presentationMode
    
    @State private var cast: [Cast] = []
    @State private var director: Crew? = nil
    @State private var writers: [Crew] = []
    @State private var dops: [Crew] = []
    @State private var composers: [Crew] = []
    @State private var editors: [Crew] = []
    
    @State private var stills: [MovieImage] = []
    @State private var showFullScreenGallery = false
    @State private var selectedImageIndex = 0
    
    @State private var currentRating: AppViewModel.RatingType? = nil
    @State private var isToWatch: Bool = false
    @State private var runtimeString: String = ""
    
    private var isGlobalContext: Bool {
        let locale = Locale.current.identifier
        return !locale.contains("CN")
    }
    
    private var isIPad: Bool { UIDevice.current.userInterfaceIdiom == .pad }
    
    var displayInfoString: String {
        var parts: [String] = []
        if !preservedGenres.isEmpty {
            parts.append(preservedGenres)
        } else if !movie.genresString.isEmpty {
            parts.append(movie.genresString)
        }
        let langStr = movie.languageString
        let countryStr = movie.countryString
        if movie.originalLanguage == "zh" || movie.originalLanguage == "cn" {
             parts.append(langStr)
        } else {
            if !countryStr.isEmpty { parts.append(countryStr) }
            if !langStr.isEmpty { parts.append(langStr) }
        }
        return parts.joined(separator: " Â· ")
    }
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                
                // 1. é¡¶éƒ¨æµ·æŠ¥
                GeometryReader { geo in
                    ZStack(alignment: .bottomLeading) {
                        TabView(selection: $selectedImageIndex) {
                            WebImage(url: movie.posterURL)
                                .resizable()
                                .indicator(.activity)
                                .aspectRatio(contentMode: .fill)
                                .frame(width: geo.size.width, height: geo.size.height)
                                .clipped()
                                .tag(0)
                            
                            ForEach(Array(stills.prefix(10).enumerated()), id: \.element) { index, image in
                                WebImage(url: image.url)
                                    .resizable()
                                    .indicator(.activity)
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: geo.size.width, height: geo.size.height)
                                    .clipped()
                                    .tag(index + 1)
                            }
                        }
                        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .automatic))
                        .onTapGesture { showFullScreenGallery = true }
                        
                        LinearGradient(colors: [.clear, .black.opacity(0.8)], startPoint: .center, endPoint: .bottom)
                            .allowsHitTesting(false)
                        
                        // ğŸŸ¢ æ–‡å­—ä¿¡æ¯åŒºåŸŸ
                        VStack(alignment: .leading, spacing: 10) {
                            HStack {
                                if let reason = movie.recommendationReason, !reason.isEmpty {
                                    Text(LocalizedStringKey(reason)).font(.caption).fontWeight(.bold).foregroundColor(.white).padding(.horizontal, 8).padding(.vertical, 4).background(Color.blue.opacity(0.8)).cornerRadius(6)
                                }
                                if (movie.voteAverage ?? 0) > 8.0 {
                                    LaurelBadge()
                                }
                            }
                            
                            Text(movie.title).font(isIPad ? .system(size: 40, weight: .bold) : .largeTitle).fontWeight(.bold).foregroundColor(.white).shadow(radius: 2)
                            
                            HStack(spacing: 12) {
                                if !movie.year.isEmpty {
                                    Text(movie.year)
                                        .font(.subheadline).bold().foregroundColor(.white)
                                        .padding(.horizontal, 8).padding(.vertical, 2)
                                        .background(Color.white.opacity(0.2)).cornerRadius(4)
                                }
                                
                                if !runtimeString.isEmpty {
                                    Text(runtimeString)
                                        .font(.subheadline).bold().foregroundColor(.white)
                                        .padding(.horizontal, 8).padding(.vertical, 2)
                                        .background(Color.white.opacity(0.2)).cornerRadius(4)
                                }
                                
                                if let score = movie.voteAverage, score > 0 {
                                    Label(String(format: "%.1f", score), systemImage: "star.fill")
                                        .foregroundColor(.yellow).font(.headline)
                                }
                            }
                            
                            Text(displayInfoString)
                                .foregroundColor(.white.opacity(0.9))
                                .font(.subheadline)
                                .lineLimit(2)
                        }
                        .padding().padding(.bottom, 20)
                        
                        // ğŸŸ¢ 2. é¢„å‘ŠæŒ‰é’®ï¼šæ”¾åœ¨å³ä¸‹è§’
                        VStack {
                            Spacer()
                            HStack {
                                Spacer()
                                PlayTrailerButton(action: openTrailer)
                                    .padding(.trailing, 20)
                                    .padding(.bottom, 30)
                            }
                        }
                    }
                }
                .frame(height: isIPad ? 700 : 500)
                
                // 3. æ“ä½œæŒ‰é’®ç»„
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        
                        // å¾…çœ‹
                        DetailActionButton(
                            icon: isToWatch ? "bookmark.fill" : "bookmark",
                            title: "å¾…çœ‹",
                            isActive: isToWatch,
                            activeColor: .blue,
                            action: toggleWatchlist
                        )
                        
                        // è¯„ä»· - å–œæ¬¢
                        DetailActionButton(
                            icon: "heart.fill",
                            title: "å–œæ¬¢",
                            isActive: currentRating == .like,
                            activeColor: .red,
                            action: { setRating(.like) }
                        )
                        
                        // è¯„ä»· - ä¸€èˆ¬
                        DetailActionButton(
                            icon: "face.smiling",
                            title: "ä¸€èˆ¬",
                            isActive: currentRating == .neutral,
                            activeColor: .orange,
                            action: { setRating(.neutral) }
                        )
                        
                        // è¯„ä»· - ä¸å–œæ¬¢
                        DetailActionButton(
                            icon: "hand.thumbsdown",
                            title: "ä¸å–œæ¬¢",
                            isActive: currentRating == .dislike,
                            activeColor: .gray,
                            action: { setRating(.dislike) }
                        )
                        
                        // è¯„ä»· - ä¸æƒ³çœ‹
                        DetailActionButton(
                            icon: "eye.slash",
                            title: "ä¸æƒ³çœ‹",
                            isActive: currentRating == .notInterested,
                            activeColor: .gray,
                            action: { setRating(.notInterested) }
                        )
                        
                        // ğŸ”´ æ³¨æ„ï¼šé¢„å‘ŠæŒ‰é’®å·²ä»è¿™é‡Œç§»åˆ°åº•éƒ¨å³ä¸‹è§’
                    }
                    .padding(.horizontal)
                }
                
                // 4. å‰§æƒ…ç®€ä»‹
                VStack(alignment: .leading, spacing: 8) {
                    Text("å‰§æƒ…ç®€ä»‹").font(.headline)
                    Text(movie.overview.isEmpty ? "æš‚æ— ç®€ä»‹" : movie.overview).font(.body).foregroundColor(.secondary).lineSpacing(4)
                }
                .padding(.horizontal)
                
                // 5. æ¼”èŒå‘˜è¡¨
                if director != nil || !writers.isEmpty || !dops.isEmpty || !composers.isEmpty || !editors.isEmpty {
                    VStack(alignment: .leading, spacing: 10) {
                        Text("å¹•åä¸»åˆ›").font(.headline).padding(.horizontal)
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(alignment: .top, spacing: 16) {
                                if let dir = director { PersonLinkCell(personId: dir.id, name: dir.name, imageURL: dir.profileURL, role: "å¯¼æ¼”") }
                                ForEach(writers) { writer in PersonLinkCell(personId: writer.id, name: writer.name, imageURL: writer.profileURL, role: "ç¼–å‰§") }
                                ForEach(dops) { dop in PersonLinkCell(personId: dop.id, name: dop.name, imageURL: dop.profileURL, role: "æ‘„å½±") }
                                ForEach(composers) { comp in PersonLinkCell(personId: comp.id, name: comp.name, imageURL: comp.profileURL, role: "é…ä¹") }
                                ForEach(editors) { ed in PersonLinkCell(personId: ed.id, name: ed.name, imageURL: ed.profileURL, role: "å‰ªè¾‘") }
                            }
                            .padding(.horizontal)
                        }
                    }
                }
                
                if !cast.isEmpty {
                    VStack(alignment: .leading, spacing: 10) {
                        Text("ä¸»è¦æ¼”å‘˜").font(.headline).padding(.horizontal)
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(alignment: .top, spacing: 16) {
                                ForEach(cast) { actor in PersonLinkCell(personId: actor.id, name: actor.name, imageURL: actor.profileURL, role: actor.character) }
                            }
                            .padding(.horizontal)
                        }
                    }
                }
                
                // 6. åˆ¶ä½œå‘è¡Œ
                if let companies = movie.productionCompanies, !companies.isEmpty {
                    VStack(alignment: .leading, spacing: 10) {
                        Text("åˆ¶ä½œå‘è¡Œ").font(.headline).padding(.horizontal)
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 20) {
                                ForEach(companies) { company in
                                    NavigationLink(destination: CompanyMoviesView(company: company)) {
                                        VStack {
                                            if let url = company.logoURL {
                                                WebImage(url: url)
                                                    .resizable()
                                                    .indicator(.activity)
                                                    .scaledToFit()
                                                    .frame(height: 40)
                                                    .padding(8)
                                                    .background(Color.white.opacity(0.9))
                                                    .cornerRadius(8)
                                            } else {
                                                Text(company.name)
                                                    .font(.caption).bold()
                                                    .padding(8)
                                                    .background(Color(UIColor.secondarySystemBackground))
                                                    .cornerRadius(8)
                                            }
                                            Text(company.name)
                                                .font(.caption2)
                                                .foregroundColor(.secondary)
                                                .lineLimit(1)
                                                .frame(width: 80)
                                        }
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                            .padding(.horizontal)
                        }
                    }
                }
                
                Spacer().frame(height: 40)
            }
        }
        .edgesIgnoringSafeArea(.top)
        .navigationBarTitleDisplayMode(.inline)
        .navigationBarBackButtonHidden(true)
        .toolbar {
            ToolbarItem(placement: .navigationBarLeading) { Button(action: { presentationMode.wrappedValue.dismiss() }) { Image(systemName: "chevron.left.circle.fill").font(.title2).foregroundColor(.white).shadow(radius: 3) } }
            ToolbarItem(placement: .navigationBarTrailing) { Button(action: shareMovie) { Image(systemName: "square.and.arrow.up.circle.fill").font(.title2).foregroundColor(.white).shadow(radius: 3) } }
        }
        .onAppear {
            checkStatus()
            Task { await loadCredits() }
            Task { await loadDetails() }
            Task { await loadImages() }
        }
        .fullScreenCover(isPresented: $showFullScreenGallery) {
            ZStack {
                Color.black.ignoresSafeArea()
                TabView(selection: $selectedImageIndex) {
                    WebImage(url: movie.posterURL).resizable().indicator(.activity).aspectRatio(contentMode: .fit).tag(0)
                    ForEach(Array(stills.prefix(10).enumerated()), id: \.element) { index, image in
                        WebImage(url: image.originalURL ?? image.url).resizable().indicator(.activity).aspectRatio(contentMode: .fit).tag(index + 1)
                    }
                }
                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))
                VStack {
                    HStack { Spacer(); Button(action: { showFullScreenGallery = false }) { Image(systemName: "xmark.circle.fill").font(.system(size: 30)).foregroundColor(.white).padding().shadow(radius: 2) } }
                    Spacer()
                }
            }
            .onTapGesture { showFullScreenGallery = false }
        }
    }
    
    // MARK: - é€»è¾‘æ–¹æ³•
    
    private func loadImages() async {
        do {
            let images = try await TMDBService.shared.fetchImages(movieId: movie.id)
            withAnimation { self.stills = images }
        } catch {}
    }
    
    private func shareMovie() {
        let template = String(localized: "æ¨èä¸€éƒ¨ç”µå½±ã€Š%@ã€‹ï¼Œè¯„åˆ† %@ï¼")
        let text = String(format: template, movie.title, String(format: "%.1f", movie.voteAverage ?? 0))
        let url = URL(string: "https://www.themoviedb.org/movie/\(movie.id)")!
        let activityVC = UIActivityViewController(activityItems: [text, url], applicationActivities: nil)
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene, let rootVC = windowScene.windows.first?.rootViewController {
            if let popover = activityVC.popoverPresentationController { popover.sourceView = rootVC.view; popover.sourceRect = CGRect(x: UIScreen.main.bounds.midX, y: UIScreen.main.bounds.midY, width: 0, height: 0); popover.permittedArrowDirections = [] }
            rootVC.present(activityVC, animated: true)
        }
    }
    
    private func checkStatus() {
        self.isToWatch = viewModel.isMovieToWatch(movie.id)
        self.currentRating = viewModel.checkRating(for: movie.id)
    }
    
    private func setRating(_ type: AppViewModel.RatingType?) {
        if let type = type {
            viewModel.rateMovie(movie: movie, type: type)
            currentRating = type
            if isToWatch { viewModel.deleteFromWatchlist(movie); isToWatch = false }
            if type != .addToWatch { DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { presentationMode.wrappedValue.dismiss() } }
        } else {
            viewModel.undoRating(for: movie)
            currentRating = nil
        }
    }
    
    private func toggleWatchlist() {
        if isToWatch {
            viewModel.deleteFromWatchlist(movie)
            isToWatch = false
        } else {
            viewModel.rateMovie(movie: movie, type: .addToWatch)
            isToWatch = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { presentationMode.wrappedValue.dismiss() }
        }
    }
    
    private var ratingIcon: String {
        switch currentRating {
        case .like: return "heart.fill"
        case .dislike: return "hand.thumbsdown.fill"
        case .neutral: return "face.smiling.inverse"
        case .notInterested: return "eye.slash.fill"
        default: return "hand.thumbsup"
        }
    }
    
    private var ratingText: String {
        switch currentRating {
        case .like: return "å·²å–œæ¬¢"
        case .dislike: return "ä¸å–œæ¬¢"
        case .neutral: return "ä¸€èˆ¬"
        case .notInterested: return "ä¸æƒ³çœ‹"
        default: return "è¯„ä»·"
        }
    }
    
    private var ratingColor: Color {
        switch currentRating {
        case .like: return .red
        case .dislike: return .gray
        case .neutral: return .orange
        case .notInterested: return .gray
        default: return .primary
        }
    }
    
    private func loadCredits() async {
        do {
            let credits = try await TMDBService.shared.fetchCredits(movieId: movie.id)
            self.cast = Array(credits.cast.prefix(15))
            if let dir = credits.crew.first(where: { $0.job == "Director" }) { self.director = dir }
            let writerJobs = ["Screenplay", "Writer", "Scenario", "Story"]
            let allWriters = credits.crew.filter { writerJobs.contains($0.job ?? "") }
            var uniqueWriters: [Crew] = []
            var seenIds: Set<Int> = []
            for writer in allWriters {
                if !seenIds.contains(writer.id) { uniqueWriters.append(writer); seenIds.insert(writer.id) }
            }
            if let dirId = self.director?.id { uniqueWriters.removeAll { $0.id == dirId } }
            self.writers = Array(uniqueWriters.prefix(3))
            
            // æ‘„å½±
            let dopList = credits.crew.filter { $0.job == "Director of Photography" }
            self.dops = Array(Set(dopList)).prefix(2).map { $0 }
            
            // é…ä¹
            let composerList = credits.crew.filter { $0.job == "Original Music Composer" || $0.job == "Composer" }
            self.composers = Array(Set(composerList)).prefix(2).map { $0 }
            
            // å‰ªè¾‘
            let editorList = credits.crew.filter { $0.job == "Editor" }
            self.editors = Array(Set(editorList)).prefix(2).map { $0 }
            
        } catch {}
    }
    
    private func loadDetails() async {
        do {
            let detail = try await TMDBService.shared.fetchMovieDetails(movieId: movie.id)
            withAnimation {
                self.movie = detail
                if let min = detail.runtime, min > 0 { self.runtimeString = detail.durationString }
            }
        } catch {}
    }
    
    private func openTrailer() {
        var keyword = movie.title
        if movie.year != "N/A" && !movie.year.isEmpty { keyword += " \(movie.year)" }
        keyword += " trailer"
        let encoded = keyword.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        if isGlobalContext {
            let appUrl = URL(string: "youtube://results?search_query=\(encoded)")!
            let webUrl = URL(string: "https://www.youtube.com/results?search_query=\(encoded)")!
            if UIApplication.shared.canOpenURL(appUrl) { UIApplication.shared.open(appUrl) } else { UIApplication.shared.open(webUrl) }
        } else {
            let cnKeyword = "\(movie.title) \(movie.year) é¢„å‘Š"
            let cnEncoded = cnKeyword.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
            let appUrl = URL(string: "bilibili://search?keyword=\(cnEncoded)")!
            let webUrl = URL(string: "https://search.bilibili.com/all?keyword=\(cnEncoded)")!
            if UIApplication.shared.canOpenURL(appUrl) { UIApplication.shared.open(appUrl) } else { UIApplication.shared.open(webUrl) }
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/SearchView.swift
// ==========================================

//
//  SearchView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SDWebImageSwiftUI

struct SearchView: View {
    @ObservedObject var viewModel: AppViewModel
    @State private var query: String = ""
    @Environment(\.presentationMode) var presentationMode
    
    // è·å–ç„¦ç‚¹çŠ¶æ€ï¼Œç”¨äºæ§åˆ¶é”®ç›˜
    @FocusState private var isFocused: Bool
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // MARK: - æœç´¢æ¡†åŒºåŸŸ
                HStack(spacing: 10) {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.gray)
                        .font(.system(size: 18))
                    
                    TextField("æœç´¢ç”µå½±ã€å¯¼æ¼”ã€æ¼”å‘˜...", text: $query)
                        .submitLabel(.search)
                        .focused($isFocused) // ç»‘å®šç„¦ç‚¹
                        .disableAutocorrection(true) // ç¦ç”¨è‡ªåŠ¨çº é”™ï¼Œé˜²æ­¢è·³åŠ¨
                        .textInputAutocapitalization(.never) // ç¦ç”¨è‡ªåŠ¨å¤§å†™
                    
                    // æ¸…é™¤æŒ‰é’®
                    if !query.isEmpty {
                        Button(action: {
                            query = ""
                            viewModel.clearSearch()
                            isFocused = true // æ¸…é™¤åä¿æŒé”®ç›˜å¼¹å‡º
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(.gray)
                                .font(.system(size: 18))
                        }
                        .transition(.opacity) // åªåšé€æ˜åº¦è¿‡æ¸¡ï¼Œä¸åšä½ç§»
                    }
                }
                .padding(.vertical, 10)
                .padding(.horizontal, 12)
                .background(Color(.systemGray6))
                .cornerRadius(10)
                .padding(.horizontal)
                .padding(.vertical, 10)
                // ğŸŸ¢ å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶ç¦ç”¨ query å˜åŒ–æ—¶çš„å¸ƒå±€åŠ¨ç”»
                // è¿™èƒ½é˜²æ­¢è¾“å…¥ç¬¬ä¸€ä¸ªå­—æ—¶ï¼Œå› ä¸º"X"æŒ‰é’®å‡ºç°å¯¼è‡´çš„å¸ƒå±€è·³åŠ¨
                .animation(nil, value: query)
                
                // æœç´¢é€»è¾‘ä»»åŠ¡ (ä¿æŒä¸å˜)
                .task(id: query) {
                    guard !query.isEmpty else {
                        await MainActor.run { viewModel.clearSearch() }
                        return
                    }
                    // é˜²æŠ–å»¶è¿Ÿï¼š0.5ç§’
                    try? await Task.sleep(nanoseconds: 500_000_000)
                    await viewModel.performSearch(query: query)
                }
                
                // MARK: - å†…å®¹åŒºåŸŸ
                ZStack {
                    if viewModel.isLoading {
                        VStack {
                            ProgressView()
                                .scaleEffect(1.2)
                                .padding(.top, 50)
                            Spacer()
                        }
                    } else if viewModel.searchResults.isEmpty && viewModel.searchPeopleResults.isEmpty && !query.isEmpty && !viewModel.isSearching {
                        // æ— ç»“æœ
                        VStack(spacing: 15) {
                            Image(systemName: "magnifyingglass")
                                .font(.system(size: 50))
                                .foregroundColor(.gray.opacity(0.5))
                            Text("æœªæ‰¾åˆ° \"\(query)\" ç›¸å…³ç»“æœ")
                                .foregroundColor(.secondary)
                        }
                        .padding(.top, 80)
                        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
                        // ğŸŸ¢ ç‚¹å‡»ç©ºç™½å¤„æ”¶èµ·é”®ç›˜
                        .contentShape(Rectangle())
                        .onTapGesture { isFocused = false }
                        
                    } else {
                        // æœ‰ç»“æœ
                        List {
                            // 1. å½±äººç»“æœ Section
                            if !viewModel.searchPeopleResults.isEmpty {
                                Section(header: Text("å½±äºº / æ¼”å‘˜")) {
                                    ForEach(viewModel.searchPeopleResults) { person in
                                        NavigationLink(destination: DirectorMoviesView(director: person)) {
                                            HStack(spacing: 12) {
                                                WebImage(url: person.profileURL)
                                                    .resizable()
                                                    .indicator(.activity)
                                                    .scaledToFill()
                                                    .frame(width: 50, height: 50)
                                                    .background(Color.gray.opacity(0.3))
                                                    .clipShape(Circle())
                                                
                                                VStack(alignment: .leading, spacing: 2) {
                                                    Text(person.name)
                                                        .font(.headline)
                                                    if let dept = person.knownForDepartment {
                                                        Text(dept == "Directing" ? "å¯¼æ¼”" : (dept == "Acting" ? "æ¼”å‘˜" : dept))
                                                            .font(.caption)
                                                            .foregroundColor(.secondary)
                                                    }
                                                }
                                            }
                                            .padding(.vertical, 4)
                                        }
                                    }
                                }
                            }
                            
                            // 2. ç”µå½±ç»“æœ Section
                            if !viewModel.searchResults.isEmpty {
                                Section(header: Text("ç”µå½±")) {
                                    ForEach(viewModel.searchResults) { movie in
                                        NavigationLink(destination: MovieDetailView(movie: movie)) {
                                            HStack(alignment: .top, spacing: 12) {
                                                WebImage(url: movie.posterURL)
                                                    .resizable()
                                                    .indicator(.activity)
                                                    .aspectRatio(contentMode: .fill)
                                                    .frame(width: 50, height: 75)
                                                    .cornerRadius(4)
                                                    .clipped()
                                                
                                                VStack(alignment: .leading, spacing: 4) {
                                                    Text(movie.title)
                                                        .font(.headline)
                                                        .lineLimit(2)
                                                    
                                                    // ä¼˜å…ˆæ˜¾ç¤ºå…³è”ç†ç”±ï¼ˆå¦‚ï¼šè¯ºå…°å¯¼æ¼”ä½œå“ï¼‰
                                                    if let reason = movie.recommendationReason {
                                                        Text(LocalizedStringKey(reason))
                                                            .font(.caption)
                                                            .fontWeight(.medium)
                                                            .foregroundColor(.blue)
                                                    } else {
                                                        Text(movie.year)
                                                            .font(.caption)
                                                            .foregroundColor(.secondary)
                                                    }
                                                    
                                                    // è¯„åˆ†
                                                    if let score = movie.voteAverage, score > 0 {
                                                        HStack(spacing: 2) {
                                                            Image(systemName: "star.fill")
                                                                .font(.system(size: 10))
                                                                .foregroundColor(.yellow)
                                                            Text(String(format: "%.1f", score))
                                                                .font(.caption)
                                                                .foregroundColor(.secondary)
                                                        }
                                                    }
                                                }
                                            }
                                            .padding(.vertical, 2)
                                        }
                                    }
                                }
                            }
                        }
                        .listStyle(.insetGrouped)
                        // æ»šåŠ¨æ—¶è‡ªåŠ¨æ”¶èµ·é”®ç›˜
                        .scrollDismissesKeyboard(.immediately)
                    }
                }
            }
            .navigationTitle("æœç´¢")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarItems(trailing: Button("å®Œæˆ") {
                viewModel.clearSearch()
                presentationMode.wrappedValue.dismiss()
            })
            // åˆšè¿›å…¥é¡µé¢æ—¶è‡ªåŠ¨å¼¹å‡ºé”®ç›˜
            .onAppear {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    isFocused = true
                }
            }
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/MovieCardView.swift
// ==========================================

//
//  MovieCardView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SDWebImageSwiftUI

struct MovieCardView: View {
    let movie: Movie
    var isOnboarding: Bool = false
    @Binding var isDetailMode: Bool
    
    @State private var showOverview: Bool = false
    private let feedback = UIImpactFeedbackGenerator(style: .medium)
    
    init(movie: Movie, isOnboarding: Bool = false, isDetailMode: Binding<Bool> = .constant(false)) {
        self.movie = movie
        self.isOnboarding = isOnboarding
        self._isDetailMode = isDetailMode
    }
    
    var body: some View {
        GeometryReader { geo in
            ZStack(alignment: .bottomLeading) {
                // 1. åº•å±‚ï¼šæµ·æŠ¥
                WebImage(url: movie.posterURL)
                    .resizable()
                    .indicator(.activity)
                    .aspectRatio(contentMode: .fill)
                    // å¡«æ»¡å®¹å™¨
                    .frame(width: geo.size.width, height: geo.size.height)
                    .clipped()
                
                // 2. ä¸­å±‚ï¼šæ¸å˜é®ç½© (Gradient Scrim)
                // ğŸŸ¢ ä¿®å¤ï¼šç§»é™¤ç£¨ç ‚ç»ç’ƒå’Œé½¿å­”ï¼Œå›å½’ç»å…¸çš„çº¿æ€§æ¸å˜
                // ç¡®ä¿æ–‡å­—åŒºåŸŸæœ‰è¶³å¤Ÿçš„å¯¹æ¯”åº¦ï¼ŒåŒæ—¶ä¸é®æŒ¡æµ·æŠ¥ä¸»ä½“
                if !showOverview {
                    LinearGradient(
                        colors: [.clear, .black.opacity(0.2), .black.opacity(0.85)],
                        startPoint: .center,
                        endPoint: .bottom
                    )
                }
                
                // 3. ä¸Šå±‚ï¼šä¿¡æ¯å†…å®¹
                if showOverview {
                    // MARK: - èƒŒé¢ï¼šå‰§æƒ…ç®€ä»‹
                    ZStack {
                        // å…¨å±åŠé€æ˜é»‘åº•
                        Color.black.opacity(0.9)
                            .ignoresSafeArea()
                        
                        VStack(alignment: .leading, spacing: 20) {
                            HStack {
                                Image(systemName: "info.circle.fill")
                                Text("å‰§æƒ…ç®€ä»‹").font(.headline)
                                Spacer()
                                Button(action: closeOverview) {
                                    Image(systemName: "xmark.circle.fill")
                                        .font(.title2)
                                        .foregroundColor(.white.opacity(0.6))
                                }
                            }
                            .foregroundColor(.white)
                            .padding(.top, 20)
                            
                            ScrollView {
                                Text(movie.overview.isEmpty ? "æš‚æ— ç®€ä»‹" : movie.overview)
                                    .font(.body)
                                    .foregroundColor(.white.opacity(0.9))
                                    .lineSpacing(6)
                            }
                            
                            Spacer()
                            
                            Text("ç‚¹å‡»å…³é—­")
                                .font(.caption).opacity(0.5).foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                        }
                        .padding(25)
                    }
                    .transition(.opacity)
                    .onTapGesture { closeOverview() }
                    
                } else {
                    // MARK: - æ­£é¢ï¼šç”µå½±ä¿¡æ¯
                    VStack(alignment: .leading, spacing: 6) {
                        Spacer()
                        
                        // æ¨èç†ç”±/ç±»å‹æ ‡ç­¾
                        let tagText = isOnboarding ? movie.genresString : movie.recommendationReason
                        if let text = tagText, !text.isEmpty {
                            Text(LocalizedStringKey(text))
                                .font(.system(size: 10, weight: .bold))
                                .foregroundColor(.white)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.blue.opacity(0.8))
                                .cornerRadius(4)
                        }
                        
                        // æ ‡é¢˜
                        Text(movie.title)
                            .font(.system(size: 22, weight: .bold, design: .rounded))
                            .foregroundColor(.white)
                            .lineLimit(2)
                            .shadow(color: .black.opacity(0.5), radius: 2, x: 0, y: 1)
                        
                        // ä¿¡æ¯è¡Œ (å¹´ä»½ Â· åœ°åŒº Â· è¯„åˆ†)
                        HStack(spacing: 8) {
                            if !movie.year.isEmpty {
                                Text(movie.year)
                                    .fontWeight(.medium)
                                    .opacity(0.8)
                            }
                            
                            // åœ°åŒº/è¯­è¨€
                            let region = !movie.countryString.isEmpty ? movie.countryString : movie.languageString
                            if !region.isEmpty {
                                Text(region)
                                    .font(.system(size: 10, weight: .bold))
                                    .padding(.horizontal, 6)
                                    .padding(.vertical, 2)
                                    .background(Color.white.opacity(0.2))
                                    .cornerRadius(4)
                            }
                            
                            Spacer()
                            
                            // è¯„åˆ†
                            if let score = movie.voteAverage, score > 0 {
                                HStack(spacing: 2) {
                                    Image(systemName: "star.fill")
                                        .font(.caption2)
                                        .foregroundColor(.yellow)
                                    Text(String(format: "%.1f", score))
                                        .fontWeight(.bold)
                                        .foregroundColor(.yellow)
                                }
                            }
                        }
                        .font(.subheadline)
                        .foregroundColor(.white)
                        
                        if isOnboarding {
                            HStack(spacing: 4) {
                                Image(systemName: "hand.tap")
                                Text("é•¿æŒ‰çœ‹ç®€ä»‹")
                            }
                            .font(.caption2)
                            .foregroundColor(.white.opacity(0.6))
                            .padding(.top, 4)
                        }
                    }
                    .padding(20)
                    .padding(.bottom, 10)
                    .transition(.opacity)
                }
            }
        }
        // å¡ç‰‡å¤–å½¢
        .aspectRatio(0.666, contentMode: .fit) // 2:3 æ ‡å‡†æµ·æŠ¥æ¯”ä¾‹
        .frame(maxWidth: .infinity)
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.2), radius: 10, x: 0, y: 5)
        // é•¿æŒ‰æ‰‹åŠ¿
        .onLongPressGesture(minimumDuration: 0.15) {
            if isOnboarding {
                feedback.impactOccurred()
                withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
                    showOverview.toggle()
                    isDetailMode = showOverview
                }
            }
        }
    }
    
    private func closeOverview() {
        withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
            showOverview = false
            isDetailMode = false
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/ProfileView.swift
// ==========================================

//
//  ProfileView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SDWebImageSwiftUI
import SwiftData

struct ProfileView: View {
    @ObservedObject var viewModel: AppViewModel
    
    @Query(filter: #Predicate<SavedMovie> { $0.isToWatch },
           sort: [SortDescriptor(\.interactionDate, order: .reverse)])
    private var watchlist: [SavedMovie]
    
    @Query(filter: #Predicate<SavedMovie> { $0.isLiked || $0.isDisliked || $0.isNeutral || $0.isWatched })
    private var seenMovies: [SavedMovie]
    
    @State private var showResetAlert = false
    @State private var showClearCacheAlert = false
    @State private var cacheSize: String = "0 MB"
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    NavigationLink(destination: RatedMoviesView()) {
                        HStack {
                            Image(systemName: "star.square.fill").foregroundColor(.yellow)
                            Text("å·²è¯„ä»·å½±ç‰‡")
                            Spacer()
                            Text("\(seenMovies.count)").foregroundColor(.gray)
                        }
                    }
                    NavigationLink(destination: HistoryView()) {
                        HStack {
                            Image(systemName: "clock.fill").foregroundColor(.blue)
                            Text("è§‚å½±è¶³è¿¹")
                            Spacer()
                            Image(systemName: "chevron.right").font(.caption).foregroundColor(.gray).opacity(0.5)
                        }
                    }
                }
                
                Section(header: Text("å¾…çœ‹æ¸…å• (\(watchlist.count))")) {
                    if watchlist.isEmpty {
                        Text("æš‚æ— å¾…çœ‹å½±ç‰‡ï¼Œå¿«å»æ¨èé¡µæ·»åŠ å§ï¼").font(.caption).foregroundColor(.gray).padding(.vertical)
                    } else {
                        ForEach(watchlist) { savedMovie in
                            NavigationLink(destination: MovieDetailView(movie: savedMovie.toMovie)) {
                                HStack {
                                    WebImage(url: savedMovie.toMovie.posterURL)
                                        .resizable().aspectRatio(contentMode: .fill).frame(width: 50, height: 75).cornerRadius(4)
                                    VStack(alignment: .leading) {
                                        Text(savedMovie.title).font(.headline)
                                        Text(String(savedMovie.releaseDate?.prefix(4) ?? "N/A")).font(.caption).foregroundColor(.gray)
                                    }
                                }
                            }
                        }
                        .onDelete(perform: deleteFromWatchList)
                    }
                }
                
                Section(header: Text("è®¾ç½®")) {
                    Button(action: {
                        calculateCacheSize()
                        showClearCacheAlert = true
                    }) {
                        HStack {
                            Image(systemName: "trash").foregroundColor(.primary)
                            Text("æ¸…é™¤å›¾ç‰‡ç¼“å­˜").foregroundColor(.primary)
                            Spacer()
                            Text(cacheSize).font(.caption).foregroundColor(.secondary)
                        }
                    }
                    .alert("æ¸…é™¤å›¾ç‰‡ç¼“å­˜", isPresented: $showClearCacheAlert) {
                        Button("å–æ¶ˆ", role: .cancel) { }
                        Button("ç¡®è®¤æ¸…é™¤", role: .destructive) { clearCache() }
                    } message: {
                        Text("ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ä¸‹è½½çš„å›¾ç‰‡ç¼“å­˜å—ï¼Ÿ")
                    }
                    
                    Button(action: { showResetAlert = true }) {
                        HStack {
                            Image(systemName: "arrow.counterclockwise").foregroundColor(.red)
                            Text("é‡ç½®å£å‘³æ•°æ®").foregroundColor(.red)
                        }
                    }
                    .alert("ç¡®å®šè¦é‡ç½®å—ï¼Ÿ", isPresented: $showResetAlert) {
                        Button("å–æ¶ˆ", role: .cancel) { }
                        Button("ç¡®å®šé‡ç½®", role: .destructive) { viewModel.resetApp() }
                    } message: {
                        Text("æ­¤æ“ä½œå°†æ¸…ç©ºæ‰€æœ‰â€œå–œæ¬¢/ä¸å–œæ¬¢â€ä»¥åŠâ€œå¾…çœ‹æ¸…å•â€çš„æ•°æ®ï¼Œä¸”æ— æ³•æ¢å¤ã€‚")
                    }
                    
                    Button(action: { viewModel.requestReview() }) {
                        HStack {
                            Image(systemName: "hand.thumbsup.fill").foregroundColor(.orange)
                            Text("ç»™ä¸ªå¥½è¯„")
                        }
                    }
                    .foregroundColor(.primary)
                }
                
                Section {
                    VStack(spacing: 8) {
                        Text("KinoTaste")
                            .font(.headline)
                            .foregroundColor(.primary.opacity(0.8))
                        
                        // åŠ¨æ€è·å– App ç‰ˆæœ¬å· (ä¾‹å¦‚ "1.1.0")
                        Text("Version \(Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0.0")")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        // ğŸŸ¢ æç®€å£°æ˜ï¼šæ»¡è¶³åˆè§„è¦æ±‚ï¼Œåˆä¸å–§å®¾å¤ºä¸»
                        Text("Data provided by TMDB")
                            .font(.system(size: 10))
                            .foregroundColor(.tertiaryLabel)
                            .padding(.top, 2)
                        
                        Text("ICPå¤‡æ¡ˆå·ï¼š") // æ¢æˆä½ çœŸå®çš„å¤‡æ¡ˆå·
                            .font(.caption2)
                            .foregroundColor(.secondary)
                            .onTapGesture {
                                // å¯é€‰ï¼šç‚¹å‡»è·³è½¬åˆ°å·¥ä¿¡éƒ¨ç½‘ç«™
                                if let url = URL(string: "https://beian.miit.gov.cn") {
                                    UIApplication.shared.open(url)
                                }
                            }
                    }
                    .frame(maxWidth: .infinity).padding(.vertical, 20)
                }
                .listRowBackground(Color.clear).listRowInsets(EdgeInsets())
            }
            .navigationTitle("æˆ‘çš„")
            .listStyle(.insetGrouped)
            .onAppear { calculateCacheSize() }
        }
    }
    
    private func deleteFromWatchList(at offsets: IndexSet) {
        for index in offsets {
            let savedMovie = watchlist[index]
            viewModel.deleteFromWatchlist(savedMovie)
        }
    }
    
    private func calculateCacheSize() {
        let size = SDImageCache.shared.totalDiskSize()
        cacheSize = ByteCountFormatter.string(fromByteCount: Int64(size), countStyle: .file)
    }
    
    private func clearCache() {
        SDImageCache.shared.clearDisk { calculateCacheSize() }
    }
}

extension Color {
    static let tertiaryLabel = Color(UIColor.tertiaryLabel)
}



// ==========================================
// FILE PATH: ./KinoTaste/SwipeLegendView.swift
// ==========================================

//
//  SwipeLegendView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/12.
//

import SwiftUI

struct SwipeLegendView: View {
    var body: some View {
        HStack(spacing: 40) {
            // 1. å·¦æ»‘ï¼šçœ‹è¿‡
            LegendItem(
                icon: "arrow.left",
                label: "çœ‹è¿‡",
                color: .blue.opacity(0.8)
            )
            
            // 2. ä¸Šæ»‘ï¼šä¸æƒ³çœ‹ (ä½œä¸ºä¸­å¿ƒï¼Œç¨å¾®å¤§ä¸€ç‚¹)
            LegendItem(
                icon: "arrow.up",
                label: "ä¸æƒ³çœ‹", // ğŸŸ¢ æ–‡æ¡ˆå·²ä¿®æ”¹
                color: .gray.opacity(0.6),
                isLarge: true
            )
            
            // 3. å³æ»‘ï¼šæƒ³çœ‹
            LegendItem(
                icon: "arrow.right",
                label: "æƒ³çœ‹",
                color: Color(red: 0.92, green: 0.85, blue: 0.55) // å¥¶é»„è‰²
            )
        }
        // ğŸŸ¢ ç§»é™¤äº† .background(...) å’Œ .cornerRadius(...)ï¼Œå»æ‰äº†ç°è‰²å¤§å¤–æ¡†
        // ğŸŸ¢ ç§»é™¤äº† .padding(...)ï¼Œä¿æŒç´§å‡‘ï¼Œæ‚¨å¯ä»¥æ ¹æ®éœ€è¦åœ¨è°ƒç”¨çš„åœ°æ–¹åŠ  padding
        .padding(.vertical, 10)
    }
}

struct LegendItem: View {
    let icon: String
    let label: String
    let color: Color
    // ğŸŸ¢ ç§»é™¤äº† subText å±æ€§
    var isLarge: Bool = false
    
    var body: some View {
        VStack(spacing: 8) {
            // åœ†å½¢å›¾æ ‡æŒ‰é’®èƒŒæ™¯
            ZStack {
                Circle()
                    .fill(Color(UIColor.systemBackground))
                    .shadow(color: .black.opacity(0.1), radius: 4, y: 2)
                
                // åŠ ç²—ç®­å¤´ (.heavy)
                Image(systemName: icon)
                    .font(.system(size: isLarge ? 24 : 20, weight: .heavy))
                    .foregroundColor(color)
            }
            .frame(width: isLarge ? 60 : 50, height: isLarge ? 60 : 50)
            .overlay(
                // æ·¡æ·¡çš„æè¾¹å¢åŠ ç²¾è‡´æ„Ÿ
                Circle().stroke(color.opacity(0.3), lineWidth: 1)
            )
            
            // æ–‡å­—è¯´æ˜ (ä»…ä¿ç•™ä¸»æ ‡é¢˜)
            Text(label)
                .font(.system(size: 12, weight: .bold))
                .foregroundColor(.primary.opacity(0.8))
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/RetroFilmOverlay.swift
// ==========================================

//
//  RetroFilmOverlay.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/12.
//

import SwiftUI

struct RetroFilmOverlay: View {
    // ğŸŸ¢ å¢å¼ºå‚æ•°ï¼šè®©æ•ˆæœæ›´æ˜æ˜¾
    var vignetteIntensity: Double = 0.8 // æš—è§’å¼ºåº¦ (0.0 - 1.0)
    var grainIntensity: Double = 0.12   // å™ªç‚¹å¼ºåº¦ (å»ºè®® 0.1 - 0.2 ä»¥è‚‰çœ¼å¯è§)
    var tintOpacity: Double = 0.3       // è‰²åæµ“åº¦
    
    var body: some View {
        ZStack {
            // 1. å¼ºåŠ›å™ªç‚¹å±‚ (Film Grain)
            // ä½¿ç”¨ Canvas ç»˜åˆ¶é«˜å¯†åº¦å™ªç‚¹
            GrainView(intensity: grainIntensity)
                .blendMode(.overlay)
                .opacity(0.6) // æé«˜ä¸é€æ˜åº¦
            
            // 2. å¤å¤æš–è‰²è°ƒ (Color Grade)
            // æ¨¡æ‹Ÿ Kodak èƒ¶ç‰‡çš„æš–é»„æ„Ÿ
            Color(red: 0.95, green: 0.90, blue: 0.80)
                .blendMode(.multiply) // æ­£ç‰‡å åº•
                .opacity(tintOpacity)
            
            // 3. æ¼å…‰æ°›å›´ (Light Leak)
            // å·¦ä¸Šè§’å†·å…‰ï¼Œå³ä¸‹è§’æš–å…‰ï¼Œå¢åŠ å±‚æ¬¡
            LinearGradient(
                colors: [
                    Color.blue.opacity(0.15),
                    Color.clear,
                    Color.orange.opacity(0.1)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .blendMode(.screen)
            
            // 4. å¼ºåŠ›æš—è§’ (Vignette)
            // å‹æš—å››å‘¨ï¼Œæ¨¡æ‹Ÿè€é•œå¤´
            RadialGradient(
                gradient: Gradient(stops: [
                    .init(color: .clear, location: 0.0), // ä¸­å¿ƒå®Œå…¨æ¸…æ™°
                    .init(color: .black.opacity(0.1), location: 0.5),
                    .init(color: .black.opacity(vignetteIntensity), location: 1.2) // è¾¹ç¼˜æ·±åº¦å‹æš—
                ]),
                center: .center,
                startRadius: 50,
                endRadius: 800
            )
            .allowsHitTesting(false)
        }
        .allowsHitTesting(false) // å…³é”®ï¼šç‚¹å‡»ç©¿é€ï¼Œä¸å½±å“æ“ä½œ
        .edgesIgnoringSafeArea(.all)
    }
}

// å™ªç‚¹ç»˜åˆ¶ç»„ä»¶
private struct GrainView: View {
    let intensity: Double
    
    var body: some View {
        GeometryReader { proxy in
            Canvas { context, size in
                let width = size.width
                let height = size.height
                // å¢åŠ å™ªç‚¹å¯†åº¦
                let dotCount = Int(width * height * 0.002)
                
                for _ in 0..<dotCount {
                    let x = Double.random(in: 0...width)
                    let y = Double.random(in: 0...height)
                    let s = Double.random(in: 1...2.5) // ç¨å¾®åŠ å¤§å™ªç‚¹å°ºå¯¸
                    let rect = CGRect(x: x, y: y, width: s, height: s)
                    // æ··åˆé»‘ç™½å™ªç‚¹
                    let gray = Double.random(in: 0...1)
                    context.fill(Path(rect), with: .color(.init(white: gray, opacity: intensity)))
                }
            }
        }
        .drawingGroup() // å¼€å¯ Metal åŠ é€Ÿ
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/RatedMoviesView.swift
// ==========================================

//
//  RatedMoviesView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SwiftData
import SDWebImageSwiftUI

struct RatedMoviesView: View {
    // ğŸŸ¢ æŸ¥è¯¢ï¼šåŒ…å« isIgnored (ä¸æƒ³çœ‹)
    @Query(filter: #Predicate<SavedMovie> { $0.isLiked || $0.isDisliked || $0.isNeutral || $0.isWatched || $0.isIgnored },
           sort: [SortDescriptor(\.interactionDate, order: .reverse)])
    private var allRatedMovies: [SavedMovie]
    
    // ç­›é€‰çŠ¶æ€ï¼š0 = å…¨éƒ¨, 1 = æˆ‘å–œæ¬¢çš„
    @State private var filterOption: Int = 0
    
    var filteredMovies: [SavedMovie] {
        switch filterOption {
        case 1: // åªçœ‹å–œæ¬¢
            return allRatedMovies.filter { $0.isLiked }
        default: // å…¨éƒ¨
            return allRatedMovies
        }
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // é¡¶éƒ¨ç­›é€‰å™¨
            Picker("ç­›é€‰", selection: $filterOption) {
                Text("å…¨éƒ¨è¯„ä»·").tag(0)
                Text("æˆ‘å–œæ¬¢çš„").tag(1)
            }
            .pickerStyle(SegmentedPickerStyle())
            .padding()
            .background(Color(UIColor.secondarySystemGroupedBackground))
            
            // åˆ—è¡¨åŒºåŸŸ
            List {
                if filteredMovies.isEmpty {
                    Text("æš‚æ— ç›¸å…³å½±ç‰‡")
                        .foregroundColor(.secondary)
                        .padding()
                } else {
                    ForEach(filteredMovies) { savedMovie in
                        // è¿™é‡Œ autoDismiss é»˜è®¤ä¸º falseï¼Œå› ä¸ºåœ¨åˆ—è¡¨é‡ŒæŸ¥çœ‹è¯¦æƒ…é€šå¸¸ä¸éœ€è¦è‡ªåŠ¨è¿”å›
                        NavigationLink(destination: MovieDetailView(movie: savedMovie.toMovie)) {
                            HStack(alignment: .top) {
                                // æµ·æŠ¥
                                WebImage(url: savedMovie.toMovie.thumbnailURL)
                                    .resizable()
                                    .indicator(.activity)
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: 50, height: 75)
                                    .cornerRadius(4)
                                    .clipped()
                                
                                VStack(alignment: .leading, spacing: 6) {
                                    Text(savedMovie.title)
                                        .font(.headline)
                                        .foregroundColor(.primary)
                                        .lineLimit(1)
                                    
                                    // æ˜¾ç¤ºåœ°åŒº/è¯­è¨€
                                    Text(savedMovie.toMovie.infoString)
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                        .lineLimit(1)
                                    
                                    HStack {
                                        // ğŸŸ¢ æ˜¾ç¤ºè¯„ä»·çŠ¶æ€
                                        if savedMovie.isLiked {
                                            Label("å–œæ¬¢", systemImage: "heart.fill").foregroundColor(.red)
                                        } else if savedMovie.isDisliked {
                                            Label("ä¸å–œæ¬¢", systemImage: "hand.thumbsdown.fill").foregroundColor(.gray)
                                        } else if savedMovie.isNeutral {
                                            Label("æ— æ„Ÿ", systemImage: "face.smiling").foregroundColor(.blue)
                                        } else if savedMovie.isIgnored {
                                            Label("ä¸æƒ³çœ‹", systemImage: "eye.slash.fill").foregroundColor(.gray) // ğŸŸ¢ æ–°å¢
                                        } else if savedMovie.isWatched {
                                            Label("çœ‹è¿‡", systemImage: "eye").foregroundColor(.secondary)
                                        }
                                        
                                        Spacer()
                                        
                                        Text(String(savedMovie.releaseDate?.prefix(4) ?? ""))
                                            .foregroundColor(.secondary)
                                    }
                                    .font(.caption)
                                }
                                .padding(.vertical, 2)
                            }
                        }
                    }
                }
            }
            .listStyle(.plain)
        }
        .navigationTitle("å·²è¯„ä»·å½±ç‰‡")
        .navigationBarTitleDisplayMode(.inline)
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/InspirationView.swift
// ==========================================

//
//  InspirationView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/12.
//

import SwiftUI

struct InspirationView: View {
    @ObservedObject var viewModel: AppViewModel
    @Environment(\.presentationMode) var presentationMode
    
    @State private var pendingMovie: Movie?
    @State private var stackID = UUID()
    
    var body: some View {
        ZStack {
            // èƒŒæ™¯
            Color(UIColor.systemBackground).ignoresSafeArea()
            
            VStack {
                // 1. é¡¶éƒ¨æ 
                HStack {
                    VStack(alignment: .leading, spacing: 2) {
                        HStack {
                            Image(systemName: "bolt.fill")
                                .foregroundColor(.yellow)
                            Text("çµæ„Ÿæ¨¡å¼")
                                .font(.system(.title2, design: .rounded))
                                .fontWeight(.bold)
                        }
                    }
                    
                    Spacer()
                    
                    // å…³é—­æŒ‰é’®
                    Button(action: {
                        presentationMode.wrappedValue.dismiss()
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title)
                            .foregroundColor(.gray.opacity(0.5))
                    }
                }
                .padding(.horizontal)
                .padding(.top, 20)
                
                Spacer()
                
                // 2. å¡ç‰‡å †å åŒº
                ZStack {
                    if viewModel.isLoading && viewModel.inspirationMovies.isEmpty {
                        VStack(spacing: 15) {
                            ProgressView()
                            Text("æ­£åœ¨å¯»æ‰¾çµæ„Ÿ...").font(.caption).foregroundColor(.gray)
                        }
                    } else if viewModel.inspirationMovies.isEmpty {
                        VStack(spacing: 15) {
                            Image(systemName: "film.stack")
                                .font(.largeTitle)
                                .foregroundColor(.gray)
                            Text("ç‰‡åº“ç©ºç©ºå¦‚ä¹Ÿ").foregroundColor(.secondary)
                            Button("åˆ·æ–°è¯•è¯•") {
                                Task { await viewModel.loadInspirationData() }
                            }
                        }
                    } else {
                        let movies = viewModel.inspirationMovies
                        let count = movies.count
                        let visibleIndices = (max(0, count - 3)..<count).map { $0 }
                        
                        ForEach(visibleIndices, id: \.self) { index in
                            let movie = movies[index]
                            let order = count - 1 - index
                            
                            DraggableCardView(
                                movie: movie,
                                isTopCard: order == 0,
                                onSwiped: { direction in
                                    handleSwipe(movie: movie, direction: direction)
                                }
                            )
                            .id(movie.id)
                            .scaleEffect(order == 0 ? 1 : (order == 1 ? 0.95 : 0.9))
                            .offset(y: order == 0 ? 0 : (order == 1 ? 15 : 30))
                            .opacity(order > 1 ? 0 : 1)
                            .zIndex(Double(index))
                            .animation(.spring(response: 0.5, dampingFraction: 0.7), value: count)
                        }
                    }
                }
                .frame(height: 500)
                .id(stackID)
                
                Spacer()
                
                // 3. åº•éƒ¨å›¾ä¾‹
                if !viewModel.inspirationMovies.isEmpty {
                    SwipeLegendView()
                        .padding(.bottom, 40)
                        .transition(.opacity)
                }
            }
            
            // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹ï¼šæ·»åŠ å¤å¤æ»¤é•œ
            RetroFilmOverlay()
        }
        .onAppear {
            Task { await viewModel.startInspirationMode() }
        }
        .sheet(item: $pendingMovie, onDismiss: { withAnimation(.spring()) { stackID = UUID() } }) { movie in
            RatingSheet(movie: movie, onSelect: { rating in
                viewModel.submitRating(for: movie, rating: rating)
                if let idx = viewModel.inspirationMovies.firstIndex(where: { $0.id == movie.id }) {
                    viewModel.inspirationMovies.remove(at: idx)
                }
                pendingMovie = nil
            }, onCancel: {
                pendingMovie = nil
            })
        }
    }
    
    private func handleSwipe(movie: Movie, direction: Int) {
        if direction == 0 { pendingMovie = movie }
        else { viewModel.handleInspirationSwipe(movie: movie, direction: direction) }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/SplashView.swift
// ==========================================

//
//  SplashView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/8.
//

import SwiftUI

struct SplashView: View {
    var body: some View {
        ZStack {
            // 1. åº•å±‚ï¼šè‡ªå®šä¹‰å…¨å±æµ·æŠ¥
            Image("LaunchImage")
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity)
                .ignoresSafeArea()
            
            // 2. ä¸Šå±‚ï¼šå±…ä¸­æ–‡å­—
            VStack(spacing: 12) {
                // ä¸»æ ‡é¢˜
                Text("ä»Šå¤©çœ‹ä»€ä¹ˆ")
                    .font(.system(size: 42, weight: .bold, design: .serif))
                    .foregroundColor(.black.opacity(0.85))
                    .tracking(4)
                    .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 2)
                
                // å‰¯æ ‡é¢˜
                Text("å‘ç°ä½ çš„ä¸‹ä¸€éƒ¨ç”µå½±")
                    .font(.system(size: 16, weight: .medium, design: .serif))
                    .italic()
                    .foregroundColor(.black.opacity(0.6))
                    .tracking(2)
            }
            .padding(.horizontal)
            .offset(y: -25)
            
            // ğŸŸ¢ 3. æœ€ä¸Šå±‚ï¼šå¤å¤æ»¤é•œ (Splashé¡µå‚æ•°æ‹‰æ»¡)
            RetroFilmOverlay(vignetteIntensity: 0.7, grainIntensity: 0.15)
        }
    }
}

struct SplashView_Previews: PreviewProvider {
    static var previews: some View {
        SplashView()
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/Models.swift
// ==========================================

//
//  Models.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//

import Foundation
import SwiftData

// MARK: - ğŸŸ¢ åŠ¨æ€åŸŸåé…ç½®
private struct ImageDomainConfig {
    static var baseURL: String {
        // è·å–ç”¨æˆ·åœ°åŒº
        let region = Locale.current.region?.identifier ?? "US"
        // å¦‚æœæ˜¯å¤§é™†ç”¨æˆ·ï¼Œèµ° .online (å¤§é™†ä¸­è½¬)ï¼Œå¦åˆ™èµ° .me (é¦™æ¸¯/æµ·å¤–)
        // æ³¨æ„ï¼šå›¾ç‰‡è·¯å¾„é€šå¸¸æ˜¯ /t/p/wXXX/
        if region == "CN" {
            return "https://api.kinotaste.me/t/p/"
        } else {
            return "https://api.kinotaste.me/t/p/"
        }
    }
}

// MARK: - API åŸºç¡€å“åº”ç»“æ„

struct TMDBResponse: Codable {
    let results: [Movie]
}

struct TMDBPersonResponse: Codable {
    let results: [Person]
}

struct VideoResponse: Codable {
    let results: [Video]
}

struct Video: Codable {
    let key: String
    let site: String
    let type: String
}

struct MovieImageResponse: Codable {
    let backdrops: [MovieImage]
    let posters: [MovieImage]
}

struct MovieImage: Identifiable, Codable, Hashable {
    let filePath: String
    var id: String { filePath }
    
    var url: URL? {
        return URL(string: "\(ImageDomainConfig.baseURL)w780\(filePath)")
    }
    
    var originalURL: URL? {
        return URL(string: "\(ImageDomainConfig.baseURL)original\(filePath)")
    }
    
    enum CodingKeys: String, CodingKey {
        case filePath = "file_path"
    }
}

// å…³é”®è¯ç»“æ„
struct KeywordResponse: Codable {
    let keywords: [Keyword]
}

struct Keyword: Identifiable, Codable {
    let id: Int
    let name: String
}

struct ProductionCompany: Identifiable, Codable, Hashable {
    let id: Int
    let name: String
    let logoPath: String?
    let originCountry: String?
    
    var logoURL: URL? {
        guard let path = logoPath else { return nil }
        return URL(string: "\(ImageDomainConfig.baseURL)w200\(path)")
    }
    
    enum CodingKeys: String, CodingKey {
        case id, name
        case logoPath = "logo_path"
        case originCountry = "origin_country"
    }
}

// MARK: - å½±äººå±¥å†æ¨¡å‹
struct PersonCreditResponse: Codable {
    let cast: [PersonMovieCredit]
    let crew: [PersonMovieCredit]
}

struct PersonMovieCredit: Identifiable, Codable {
    let id: Int
    let title: String
    let posterPath: String?
    let overview: String
    let releaseDate: String?
    let genreIds: [Int]?
    let voteAverage: Double?
    let voteCount: Int?
    let adult: Bool?
    let originCountry: [String]?
    let originalLanguage: String?
    let job: String?
    let character: String?
    
    func toMovie(reason: String? = nil) -> Movie {
        Movie(
            id: id,
            title: title,
            posterPath: posterPath,
            overview: overview,
            releaseDate: releaseDate,
            genreIds: genreIds,
            voteAverage: voteAverage,
            voteCount: voteCount,
            adult: adult,
            originCountry: originCountry,
            originalLanguage: originalLanguage,
            runtime: nil,
            productionCompanies: nil,
            recommendationReason: reason
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case id, title, overview, job, character
        case releaseDate = "release_date"
        case posterPath = "poster_path"
        case genreIds = "genre_ids"
        case voteAverage = "vote_average"
        case voteCount = "vote_count"
        case adult
        case originCountry = "origin_country"
        case originalLanguage = "original_language"
    }
}

// MARK: - äººç‰©/æ¼”èŒå‘˜æ¨¡å‹

struct Person: Identifiable, Codable, Hashable {
    let id: Int
    let name: String
    let originalName: String?
    let knownForDepartment: String?
    let profilePath: String?
    let popularity: Double?
    
    var profileURL: URL? {
        guard let path = profilePath else { return nil }
        return URL(string: "\(ImageDomainConfig.baseURL)w200\(path)")
    }
    
    enum CodingKeys: String, CodingKey {
        case id, name, popularity
        case originalName = "original_name"
        case knownForDepartment = "known_for_department"
        case profilePath = "profile_path"
    }
}

struct CreditsResponse: Codable {
    let cast: [Cast]
    let crew: [Crew]
}

struct Cast: Identifiable, Codable, Hashable {
    let id: Int
    let name: String
    let originalName: String?
    let character: String
    let profilePath: String?
    
    var profileURL: URL? {
        guard let path = profilePath else { return nil }
        return URL(string: "\(ImageDomainConfig.baseURL)w200\(path)")
    }
    
    enum CodingKeys: String, CodingKey {
        case id, name, character
        case originalName = "original_name"
        case profilePath = "profile_path"
    }
}

struct Crew: Identifiable, Codable, Hashable {
    let id: Int
    let name: String
    let originalName: String?
    let job: String
    let profilePath: String?
    
    var profileURL: URL? {
        guard let path = profilePath else { return nil }
        return URL(string: "\(ImageDomainConfig.baseURL)w200\(path)")
    }
    
    enum CodingKeys: String, CodingKey {
        case id, name, job
        case originalName = "original_name"
        case profilePath = "profile_path"
    }
}

// MARK: - æ ¸å¿ƒç”µå½±æ¨¡å‹

struct Movie: Identifiable, Codable, Equatable, Hashable {
    let id: Int
    let title: String
    let posterPath: String?
    let overview: String
    let releaseDate: String?
    let genreIds: [Int]?
    let voteAverage: Double?
    let voteCount: Int?
    let adult: Bool?
    let originCountry: [String]?
    let originalLanguage: String?
    let runtime: Int?
    let productionCompanies: [ProductionCompany]?
    
    var recommendationReason: String? = nil
    
    var isAdult: Bool { return adult ?? false }
    
    var posterURL: URL? {
        guard let path = posterPath else { return nil }
        return URL(string: "\(ImageDomainConfig.baseURL)w500\(path)")
    }
    
    var thumbnailURL: URL? {
        guard let path = posterPath else { return nil }
        return URL(string: "\(ImageDomainConfig.baseURL)w342\(path)")
    }
    
    var year: String {
        return String(releaseDate?.prefix(4) ?? "N/A")
    }
    
    var durationString: String {
        guard let min = runtime, min > 0 else { return "" }
        let h = min / 60
        let m = min % 60
        if h > 0 {
            return "\(h)å°æ—¶\(m)åˆ†"
        } else {
            return "\(m)åˆ†é’Ÿ"
        }
    }
    
    var genresString: String {
        guard let ids = genreIds else { return "" }
        return ids.compactMap { TMDBService.genreMap[$0] }
            .prefix(2)
            .joined(separator: " / ")
    }
    
    var countryString: String {
        let locale = Locale.current
        if let countries = originCountry, let code = countries.first, !code.isEmpty {
            return locale.localizedString(forRegionCode: code) ?? code
        }
        return ""
    }
    
    var languageString: String {
        guard let lang = originalLanguage, !lang.isEmpty else { return "" }
        if lang == "zh" || lang == "cn" {
            if lang == "cn" { return "ç²¤è¯­" }
            if let country = originCountry?.first {
                switch country {
                case "HK", "MO": return "ç²¤è¯­"
                case "TW": return "å›½è¯­/é—½å—"
                case "CN": return "å›½è¯­"
                default: return "åè¯­"
                }
            }
            return "åè¯­"
        }
        let locale = Locale.current
        return locale.localizedString(forIdentifier: lang) ?? lang
    }
    
    var infoString: String {
        var parts: [String] = []
        if !genresString.isEmpty { parts.append(genresString) }
        let langStr = languageString
        let countryStr = countryString
        if originalLanguage == "zh" || originalLanguage == "cn" {
             parts.append(langStr)
        } else {
            if !countryStr.isEmpty { parts.append(countryStr) }
            if !langStr.isEmpty { parts.append(langStr) }
        }
        return parts.joined(separator: " Â· ")
    }
    
    var onboardingInfoString: String {
        var parts: [String] = []
        if !year.isEmpty && year != "N/A" { parts.append(year) }
        if !countryString.isEmpty { parts.append(countryString) }
        return parts.joined(separator: " Â· ")
    }
    
    enum CodingKeys: String, CodingKey {
        case id, title, overview, runtime
        case releaseDate = "release_date"
        case posterPath = "poster_path"
        case genreIds = "genre_ids"
        case voteAverage = "vote_average"
        case voteCount = "vote_count"
        case adult
        case originCountry = "origin_country"
        case originalLanguage = "original_language"
        case productionCompanies = "production_companies"
    }
}

// MARK: - SwiftData æ•°æ®åº“æ¨¡å‹

@Model
class SavedMovie {
    @Attribute(.unique) var id: Int
    var title: String
    var posterPath: String?
    var overview: String
    var releaseDate: String?
    var genreIds: [Int]
    var voteAverage: Double?
    var originCountry: [String]?
    var originalLanguage: String?
    
    // çŠ¶æ€ä½
    var isLiked: Bool = false
    var isDisliked: Bool = false
    var isNeutral: Bool = false
    var isToWatch: Bool = false
    var isWatched: Bool = false
    var isIgnored: Bool = false
    
    var interactionDate: Date = Date()
    
    init(from movie: Movie) {
        self.id = movie.id
        self.title = movie.title
        self.posterPath = movie.posterPath
        self.overview = movie.overview
        self.releaseDate = movie.releaseDate
        self.genreIds = movie.genreIds ?? []
        self.voteAverage = movie.voteAverage
        self.originCountry = movie.originCountry
        self.originalLanguage = movie.originalLanguage
    }
    
    var toMovie: Movie {
        Movie(
            id: id,
            title: title,
            posterPath: posterPath,
            overview: overview,
            releaseDate: releaseDate,
            genreIds: genreIds,
            voteAverage: voteAverage,
            voteCount: 1000,
            adult: false,
            originCountry: originCountry,
            originalLanguage: originalLanguage,
            runtime: nil,
            productionCompanies: nil,
            recommendationReason: nil
        )
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/AppViewModel.swift
// ==========================================

//
//  AppViewModel.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SwiftData
import StoreKit
import Combine

struct CategoryItem: Identifiable, Equatable {
    let id: String
    let name: String
    let type: CategoryType
    let value: String
    let sortGenreId: Int
    
    enum CategoryType {
        case genre
        case keyword
        case language
        case custom   // ç”¨äºå¤æ‚é€»è¾‘
    }
}

@MainActor
class AppViewModel: ObservableObject {
    
    enum AppState { case onboarding, dashboard }
    
    enum RatingType { case like, dislike, neutral, addToWatch, watched, notInterested }
    
    // MARK: - çŠ¶æ€å˜é‡
    @Published var showSplash: Bool = true
    @Published var appState: AppState = .onboarding
    @Published var isLoading: Bool = false
    @Published var errorMessage: String? = nil
    
    // ğŸŸ¢ éšç§æ”¿ç­–åŒæ„çŠ¶æ€ (æ ¸å¿ƒåˆè§„ä¿®æ”¹)
    // é»˜è®¤è¯»å–æœ¬åœ°å­˜å‚¨ï¼Œå¦‚æœæ²¡æœ‰è®°å½•åˆ™ä¸º false
    @Published var hasAgreedPrivacy: Bool = UserDefaults.standard.bool(forKey: "UserAgreedPrivacy")
    
    @Published var onboardingMovies: [Movie] = []
    @Published var recommendedMovies: [Movie] = []
    
    @Published var isSearching: Bool = false
    @Published var searchResults: [Movie] = []
    @Published var searchPeopleResults: [Person] = []
    
    @Published var selectedCategory: CategoryItem? = nil
    
    private var modelContext: ModelContext?
    private let worldLanguages = ["ja", "ko", "fr", "de", "it", "es", "th", "hi", "pt", "da", "sv", "fa", "ru", "nl", "pl"]
    
    private let bannedGenres: Set<Int> = [10770] // ä»…è¿‡æ»¤ç”µè§†ç”µå½±
    
    // æ•æ„Ÿå…³é”®è¯é»‘åå• (è‰²æƒ…ã€è£¸éœ²ã€è½¯è‰²æƒ…ç­‰)
    private let blockedKeywords = "190678,9826,156372,246237,175657"
    
    private let bannedTitleKeywords: [String] = [
        "æ¼”å”±ä¼š", "å·¡æ¼”", "å·¡å›", "live in", "concert", "tour",
        "sex", "erotic", "porn", "è‰²æƒ…", "ä¸‰çº§", "æƒ…è‰²", "av",
        "nudity", "hentai", "xxx", "erotica"
    ]
    
    // MARK: - åˆ†ç±»åˆ—è¡¨
    let categories: [CategoryItem] = [
        CategoryItem(id: "custom-upcoming", name: "ğŸ“… å€¼å¾—æœŸå¾…", type: .custom, value: "upcoming", sortGenreId: 0),
        CategoryItem(id: "custom-healing", name: "â˜€ï¸ æ²»æ„ˆæ—¶å…‰", type: .custom, value: "healing", sortGenreId: 10751),
        CategoryItem(id: "g-10749", name: "ğŸ’Œ é‡è§çˆ±æƒ…", type: .genre, value: "10749", sortGenreId: 10749),
        CategoryItem(id: "g-35", name: "ğŸ˜‚ è½»æ¾ä¸€åˆ»", type: .genre, value: "35", sortGenreId: 35),
        CategoryItem(id: "g-9648", name: "ğŸ§  æè‡´çƒ§è„‘", type: .genre, value: "9648", sortGenreId: 9648),
        CategoryItem(id: "g-878", name: "ğŸš€ ç¡¬æ ¸ç§‘å¹»", type: .genre, value: "878", sortGenreId: 878),
        CategoryItem(id: "lang-yue", name: "ğŸ‡­ğŸ‡° æ¸¯äº§å²æœˆ", type: .language, value: "cn", sortGenreId: 28),
        CategoryItem(id: "g-16", name: "ğŸ–Œï¸ è§†è§‰åŠ¨ç”»", type: .genre, value: "16", sortGenreId: 16),
        CategoryItem(id: "g-80", name: "ğŸ”« å†·ç¡¬çŠ¯ç½ª", type: .genre, value: "80", sortGenreId: 80),
        CategoryItem(id: "k-9672", name: "ğŸ“– çœŸå®äº‹ä»¶", type: .keyword, value: "9672", sortGenreId: 18)
    ]
    
    var sortedCategories: [CategoryItem] {
        let scores = genreScores
        return categories.sorted { item1, item2 in
            if item1.value == "upcoming" { return true }
            if item2.value == "upcoming" { return false }
            
            let score1 = scores[item1.sortGenreId] ?? 0
            let score2 = scores[item2.sortGenreId] ?? 0
            return score1 > score2
        }
    }
    
    // MARK: - åŠ¨æ€è®¡ç®—å±æ€§
    var seenMovieIds: Set<Int> {
        guard let context = modelContext else { return [] }
        let descriptor = FetchDescriptor<SavedMovie>(
            predicate: #Predicate { $0.isLiked || $0.isDisliked || $0.isNeutral || $0.isWatched || $0.isIgnored }
        )
        let saved = (try? context.fetch(descriptor)) ?? []
        return Set(saved.map { $0.id })
    }
    
    var likedMovies: [SavedMovie] {
        guard let context = modelContext else { return [] }
        let descriptor = FetchDescriptor<SavedMovie>(
            predicate: #Predicate { $0.isLiked },
            sortBy: [SortDescriptor(\.interactionDate, order: .reverse)]
        )
        return (try? context.fetch(descriptor)) ?? []
    }
    
    var likedMovieIds: [Int] {
        guard let context = modelContext else { return [] }
        let descriptor = FetchDescriptor<SavedMovie>(predicate: #Predicate { $0.isLiked })
        return (try? context.fetch(descriptor))?.map { $0.id } ?? []
    }
    
    var toWatchList: [Movie] {
        guard let context = modelContext else { return [] }
        let descriptor = FetchDescriptor<SavedMovie>(
            predicate: #Predicate { $0.isToWatch },
            sortBy: [SortDescriptor(\.interactionDate, order: .reverse)]
        )
        return (try? context.fetch(descriptor))?.map { $0.toMovie } ?? []
    }
    
    var genreScores: [Int: Int] {
        guard let context = modelContext else { return [:] }
        let descriptor = FetchDescriptor<SavedMovie>(
            predicate: #Predicate { $0.isLiked || $0.isDisliked || $0.isNeutral || $0.isToWatch || $0.isIgnored }
        )
        let saved = (try? context.fetch(descriptor)) ?? []
        
        var scores: [Int: Int] = [:]
        let now = Date()
        let calendar = Calendar.current
        
        for movie in saved {
            var weight = 0.0
            if movie.isLiked { weight = 5.0 }
            else if movie.isDisliked { weight = -5.0 }
            else if movie.isIgnored { weight = -3.0 }
            else if movie.isToWatch { weight = 3.0 }
            else if movie.isNeutral { weight = 0.5 }
            
            let daysSince = calendar.dateComponents([.day], from: movie.interactionDate, to: now).day ?? 0
            if daysSince < 30 { weight *= 1.5 }
            else if daysSince > 90 { weight *= 0.5 }
            
            for genre in movie.genreIds { scores[genre, default: 0] += Int(weight) }
        }
        return scores
    }
    
    var seenCount: Int { seenMovieIds.count }
    
    // MARK: - åˆå§‹åŒ–
    func setContext(_ context: ModelContext) {
        self.modelContext = context
        // ğŸŸ¢ å…³é”®åˆè§„é€»è¾‘ï¼šåªæœ‰ç”¨æˆ·å·²åŒæ„éšç§ï¼Œæ‰å¼€å§‹è”ç½‘åŠ è½½
        if hasAgreedPrivacy {
            checkAppState()
        } else {
            // å¦‚æœæ²¡åŒæ„ï¼Œä¸è¿›è¡Œä»»ä½•ç½‘ç»œåŠ è½½ï¼Œåªä¿æŒ Splash æˆ–æ˜¾ç¤ºéšç§é¡µ
            self.showSplash = false
        }
    }
    
    // åœ¨ AppViewModel ç±»ä¸­æ·»åŠ 
        func toggleWatchlistContext(_ movie: Movie) {
            if isMovieToWatch(movie.id) {
                deleteFromWatchlist(movie)
            } else {
                rateMovie(movie: movie, type: .addToWatch)
            }
        }
    
    // ğŸŸ¢ æ–°å¢ï¼šç”¨æˆ·ç‚¹å‡»åŒæ„åè§¦å‘çš„æ–¹æ³•
    func agreePrivacy() {
        self.hasAgreedPrivacy = true
        UserDefaults.standard.set(true, forKey: "UserAgreedPrivacy")
        // åŒæ„åï¼Œç«‹å³å¼€å§‹æ£€æŸ¥çŠ¶æ€å¹¶åŠ è½½æ•°æ®
        checkAppState()
    }
    
    private func checkAppState() {
        Task {
            let isDashboard = seenCount >= 10
            
            async let minDisplayTime = try? Task.sleep(nanoseconds: 800_000_000)
            
            async let dataLoading: Void = {
                if isDashboard {
                    await refreshRecommendations(reset: true)
                } else {
                    await loadOnboardingMovies()
                }
            }()
            
            _ = await (minDisplayTime, dataLoading)
            
            self.appState = isDashboard ? .dashboard : .onboarding
            withAnimation(.easeOut(duration: 0.3)) { self.showSplash = false }
        }
    }
    
    func isMovieLiked(_ movieId: Int) -> Bool { return likedMovieIds.contains(movieId) }
    func isMovieToWatch(_ movieId: Int) -> Bool { return toWatchList.contains(where: { $0.id == movieId }) }
    
    func checkRating(for movieId: Int) -> RatingType? {
        guard let context = modelContext else { return nil }
        let descriptor = FetchDescriptor<SavedMovie>(predicate: #Predicate { $0.id == movieId })
        guard let saved = try? context.fetch(descriptor).first else { return nil }
        
        if saved.isLiked { return .like }
        if saved.isDisliked { return .dislike }
        if saved.isNeutral { return .neutral }
        if saved.isIgnored { return .notInterested }
        return nil
    }
    
    // MARK: - äº¤äº’é€»è¾‘
    func rateMovie(movie: Movie, type: RatingType) {
        guard let context = modelContext else { return }
        let movieId = movie.id
        let descriptor = FetchDescriptor<SavedMovie>(predicate: #Predicate { $0.id == movieId })
        let existing = try? context.fetch(descriptor).first
        let savedMovie = existing ?? SavedMovie(from: movie)
        if existing == nil { context.insert(savedMovie) }
        savedMovie.interactionDate = Date()
        
        savedMovie.isLiked = false
        savedMovie.isDisliked = false
        savedMovie.isNeutral = false
        savedMovie.isIgnored = false
        
        switch type {
        case .like:
            savedMovie.isLiked = true; savedMovie.isWatched = true; savedMovie.isToWatch = false
        case .dislike:
            savedMovie.isDisliked = true; savedMovie.isWatched = true; savedMovie.isToWatch = false
        case .neutral:
            savedMovie.isNeutral = true; savedMovie.isWatched = true; savedMovie.isToWatch = false
        case .notInterested:
            savedMovie.isIgnored = true; savedMovie.isWatched = false; savedMovie.isToWatch = false
        case .addToWatch:
            savedMovie.isToWatch = true
        case .watched:
            savedMovie.isWatched = true; savedMovie.isToWatch = false
        }
        
        try? context.save()
        
        if appState == .dashboard && !isSearching {
            removeFromRecommendations(movie)
        }
        
        if type == .like { checkAndAskForReview() }
    }
    
    func removeFromRecommendations(_ movie: Movie) {
        withAnimation {
            recommendedMovies.removeAll { $0.id == movie.id }
        }
    }
    
    func undoRating(for movie: Movie) {
        guard let context = modelContext else { return }
        let movieId = movie.id
        let descriptor = FetchDescriptor<SavedMovie>(predicate: #Predicate { $0.id == movieId })
        
        if let savedMovie = try? context.fetch(descriptor).first {
            savedMovie.isLiked = false
            savedMovie.isDisliked = false
            savedMovie.isNeutral = false
            savedMovie.isIgnored = false
            savedMovie.isWatched = false
            try? context.save()
        }
    }
    
    func deleteFromWatchlist(_ movie: Movie) {
        guard let context = modelContext else { return }
        let movieId = movie.id
        let descriptor = FetchDescriptor<SavedMovie>(predicate: #Predicate { $0.id == movieId })
        
        if let savedMovie = try? context.fetch(descriptor).first {
            savedMovie.isToWatch = false
            try? context.save()
        }
    }
    
    func deleteFromWatchlist(_ savedMovie: SavedMovie) {
        savedMovie.isToWatch = false
        try? modelContext?.save()
    }
    
    func handleQuickSwipe(movie: Movie, direction: Int) {
        switch direction {
        case 0: rateMovie(movie: movie, type: .watched); removeCardFromList(movie)
        case 1: rateMovie(movie: movie, type: .notInterested); removeCardFromList(movie)
        case 2: rateMovie(movie: movie, type: .addToWatch); removeCardFromList(movie)
        default: break
        }
    }
    
    func submitRating(for movie: Movie, rating: RatingType) {
        rateMovie(movie: movie, type: rating)
        removeCardFromList(movie)
    }
    
    private func removeCardFromList(_ movie: Movie) {
        withAnimation {
            if let index = onboardingMovies.firstIndex(where: { $0.id == movie.id }) { onboardingMovies.remove(at: index) }
        }
        if appState == .onboarding && onboardingMovies.isEmpty { completeOnboarding() }
    }
    
    func requeueMovie(_ movie: Movie) {
        withAnimation {
            if let index = onboardingMovies.firstIndex(where: { $0.id == movie.id }) {
                let item = onboardingMovies.remove(at: index)
                onboardingMovies.append(item)
            }
        }
    }
    
    // MARK: - çµæ„Ÿ/ç›²ç›’æ¨¡å¼ (Inspiration Mode)
        @Published var inspirationMovies: [Movie] = []
        
        // è¿›å…¥çµæ„Ÿæ¨¡å¼æ—¶è°ƒç”¨
        func startInspirationMode() async {
            // å¦‚æœæ± å­é‡Œæ²¡è´§äº†ï¼Œæˆ–è€…åªæœ‰å¾ˆå°‘ï¼Œå°±åŠ è½½æ–°çš„
            if inspirationMovies.count < 3 {
                await loadInspirationData()
            }
        }
        
    func loadInspirationData() async {
            isLoading = true
            do {
                // ç›²ç›’ç­–ç•¥ï¼šæ··åˆâ€œé«˜åˆ†ç»å…¸â€ã€â€œçƒ­é—¨æµè¡Œâ€å’Œâ€œå†·é—¨ä½³ç‰‡â€
                // ğŸŸ¢ ä¿®å¤ï¼šè¡¥å…¨äº† includeGenres: [] å’Œ excludeGenres: [] å‚æ•°
                async let b1 = TMDBService.shared.fetchRecommendations(
                    includeGenres: [],
                    excludeGenres: [],
                    sortBy: "vote_average.desc",
                    minVoteCount: 500,
                    page: Int.random(in: 1...20)
                )
                
                async let b2 = TMDBService.shared.fetchRecommendations(
                    includeGenres: [],
                    excludeGenres: [],
                    sortBy: "popularity.desc",
                    page: Int.random(in: 1...10)
                )
                
                // å†·é—¨ä½³ç‰‡
                async let b3 = TMDBService.shared.fetchRecommendations(
                    includeGenres: [],
                    excludeGenres: [],
                    sortBy: "vote_average.desc",
                    minVoteCount: 100,
                    page: Int.random(in: 1...30)
                )
                
                let (r1, r2, r3) = try await (b1, b2, b3)
                
                // 1. æ··åˆç»“æœ
                var pool = r1 + r2 + r3
                pool.shuffle()
                
                // 2. è¿‡æ»¤ï¼šå»æ‰å·²çœ‹/å·²æ ‡è®°/æ— æ•ˆçš„
                let existingIds = seenMovieIds.union(Set(toWatchList.map { $0.id }))
                let filtered = pool.filter { !existingIds.contains($0.id) && isValidMovie($0) }
                
                // 3. å»é‡å¹¶æ·»åŠ ç†ç”±
                var uniqueMovies: [Movie] = []
                var seenIds = Set<Int>()
                
                // ç°æœ‰çš„çµæ„Ÿåˆ—è¡¨ä¹Ÿè¦ç®—è¿›å·²å­˜åœ¨ï¼Œé˜²æ­¢é‡å¤æ·»åŠ 
                let currentInspirationIds = Set(inspirationMovies.map { $0.id })
                
                for m in filtered {
                    if !seenIds.contains(m.id) && !currentInspirationIds.contains(m.id) {
                        // ç»™ç›²ç›’åŠ ä¸€ç‚¹ç¥ç§˜æ„Ÿæ–‡æ¡ˆ
                        let reasons = ["âœ¨ çµæ„Ÿæ¨è", "ğŸ² ç›²ç›’æƒŠå–œ", "ğŸ¬ å€¼å¾—ä¸€è¯•", "ğŸ¿ ä¹Ÿå°±æ˜¯çœ‹éƒ¨ç”µå½±çš„äº‹"]
                        uniqueMovies.append(addReason(m, reasons.randomElement()!))
                        seenIds.insert(m.id)
                    }
                }
                
                await MainActor.run {
                    self.inspirationMovies.append(contentsOf: uniqueMovies)
                    self.isLoading = false
                }
            } catch {
                await MainActor.run { self.isLoading = false }
            }
        }
        
        func handleInspirationSwipe(movie: Movie, direction: Int) {
            // å¤ç”¨é€šç”¨çš„è¯„åˆ†é€»è¾‘
            // 0: å·¦æ»‘(çœ‹è¿‡->å¼¹çª—), 1: ä¸Šæ»‘(ä¸æƒ³çœ‹), 2: å³æ»‘(æƒ³çœ‹)
            // æ³¨æ„ï¼šè¿™é‡Œåªå¤„ç† ä¸Šæ»‘å’Œå³æ»‘ çš„ç›´æ¥é€»è¾‘ï¼Œå·¦æ»‘(çœ‹è¿‡)ç”± View å±‚å¼¹çª—å¤„ç†å®Œåè°ƒç”¨ submitRating
            if direction != 0 {
                handleQuickSwipe(movie: movie, direction: direction)
            }
            
            // ä»çµæ„Ÿåˆ—è¡¨ä¸­ç§»é™¤è¯¥å¡ç‰‡
            withAnimation {
                if let index = inspirationMovies.firstIndex(where: { $0.id == movie.id }) {
                    inspirationMovies.remove(at: index)
                }
            }
            
            // é¢„åŠ è½½æœºåˆ¶ï¼šå¦‚æœè¿™å°±å‰©ä¸åˆ°5å¼ äº†ï¼Œèµ¶ç´§å»æŠ“æ–°çš„
            if inspirationMovies.count < 5 {
                Task { await loadInspirationData() }
            }
        }
    
    // MARK: - æœç´¢ & æ¨èé€»è¾‘
    func performSearch(query: String) async {
        guard !query.isEmpty else { isSearching = false; return }
        isSearching = true; isLoading = true
        do {
            async let fetchMovies = TMDBService.shared.searchMovies(query: query)
            async let fetchPeople = TMDBService.shared.searchPeople(query: query)
            let (movieResults, peopleResults) = try await (fetchMovies, fetchPeople)
            self.searchPeopleResults = peopleResults
            var combinedResults: [Movie] = []
            if let person = peopleResults.first {
                let works = try await self.fetchPersonWorks(personId: person.id)
                combinedResults.append(contentsOf: works.prefix(5))
            }
            for m in movieResults { combinedResults.append(self.addReason(m, generateBasicInfo(for: m))) }
            let validResults = combinedResults.filter { isValidMovie($0) && $0.posterPath != nil }
            var unique: [Movie] = []
            for m in validResults { if !unique.contains(where: { $0.id == m.id }) { unique.append(m) } }
            self.searchResults = unique
        } catch {}
        isLoading = false
    }
    
    func clearSearch() { isSearching = false; searchResults = []; searchPeopleResults = [] }
    
    func fetchPersonWorks(personId: Int) async throws -> [Movie] {
        let credits = try await TMDBService.shared.fetchPersonCredits(personId: personId)
        var movies: [Movie] = []
        var addedIds: Set<Int> = []
        
        let jobPriority = [
            "Director": 1, "Screenplay": 2, "Writer": 2,
            "Director of Photography": 3, "Original Music Composer": 3, "Composer": 3, "Editor": 3,
            "Producer": 4
        ]
        
        let sortedCrew = credits.crew.sorted {
            let p1 = jobPriority[$0.job ?? ""] ?? 99
            let p2 = jobPriority[$1.job ?? ""] ?? 99
            return p1 < p2
        }
        
        for item in sortedCrew {
            if !addedIds.contains(item.id) {
                var reason = item.job ?? "å¹•å"
                switch reason {
                case "Director": reason = localized("å¯¼æ¼”")
                case "Screenplay", "Writer": reason = localized("ç¼–å‰§")
                case "Director of Photography": reason = localized("æ‘„å½±")
                case "Original Music Composer", "Composer": reason = localized("é…ä¹")
                case "Editor": reason = localized("å‰ªè¾‘")
                case "Producer", "Executive Producer": reason = localized("ç›‘åˆ¶")
                default: if jobPriority[item.job ?? ""] == nil { continue }
                }
                movies.append(item.toMovie(reason: reason))
                addedIds.insert(item.id)
            }
        }
        
        let sortedCast = credits.cast.sorted { ($0.voteCount ?? 0) > ($1.voteCount ?? 0) }
        for item in sortedCast {
            if !addedIds.contains(item.id) {
                let charName = item.character ?? ""
                let reason = charName.isEmpty ? localized("ä¸»æ¼”") : localized("é¥° %@", charName)
                movies.append(item.toMovie(reason: reason))
                addedIds.insert(item.id)
            }
        }
        
        return movies.filter { $0.posterPath != nil && !$0.title.isEmpty }
    }
    
    private func processAndAssignMovies(_ movies: [Movie], currentSeen: Set<Int>, currentWatch: [Int], reset: Bool) {
        let validPool = movies.filter { isValidMovie($0) && $0.posterPath != nil && !currentSeen.contains($0.id) && !currentWatch.contains($0.id) }
        
        var uniqueMovies: [Movie] = []
        for m in validPool { if !uniqueMovies.contains(where: { $0.id == m.id }) { uniqueMovies.append(m) } }
        
        let finalList: [Movie]
        if selectedCategory?.value == "upcoming" {
            finalList = uniqueMovies
        } else {
            finalList = uniqueMovies.shuffled()
        }
        
        withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
            if reset { self.recommendedMovies = Array(finalList.prefix(15)) }
            else { self.recommendedMovies.append(contentsOf: finalList.filter { m in !self.recommendedMovies.contains(where: { $0.id == m.id }) }) }
        }
    }
    
    func changeCategory(to item: CategoryItem?) async {
        if selectedCategory != item { selectedCategory = item; await refreshRecommendations(reset: true) }
    }
    
    func refreshRecommendations(reset: Bool = true) async {
        withAnimation {
            isLoading = true
            if reset { errorMessage = nil; recommendedMovies = [] }
        }
        
        defer { withAnimation { isLoading = false } }
        let currentSeen = seenMovieIds; let currentWatch = toWatchList.map { $0.id }
        if let category = selectedCategory {
            do {
                var fetchedMovies: [Movie] = []
                
                switch category.type {
                case .custom:
                    if category.value == "upcoming" {
                        let formatter = DateFormatter()
                        formatter.dateFormat = "yyyy-MM-dd"
                        let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: Date())!
                        let future = Calendar.current.date(byAdding: .month, value: 6, to: Date())!
                        
                        fetchedMovies = try await TMDBService.shared.fetchRecommendations(
                            includeGenres: [], excludeGenres: [],
                            releaseDateGte: formatter.string(from: tomorrow),
                            releaseDateLte: formatter.string(from: future),
                            sortBy: "popularity.desc",
                            minVoteCount: 0,
                            page: Int.random(in: 1...2)
                        )
                    }
                    else if category.value == "healing" {
                        fetchedMovies = try await TMDBService.shared.fetchRecommendations(
                            includeGenres: [10751],
                            excludeGenres: [27, 53, 80],
                            sortBy: "vote_average.desc",
                            minVoteCount: 100,
                            page: Int.random(in: 1...3)
                        )
                        let more = try await TMDBService.shared.fetchRecommendations(
                            includeGenres: [10402],
                            excludeGenres: [27, 53],
                            sortBy: "vote_average.desc",
                            minVoteCount: 100,
                            page: 1
                        )
                        fetchedMovies.append(contentsOf: more)
                    }
                    
                case .genre:
                    if let val = Int(category.value) {
                        if val == 10749 {
                            fetchedMovies = try await TMDBService.shared.fetchRecommendations(
                                includeGenres: [val], excludeGenres: [27, 53],
                                withoutKeywords: blockedKeywords,
                                sortBy: "popularity.desc",
                                minVoteCount: 100,
                                page: Int.random(in: 1...3)
                            )
                        }
                        else if val == 35 {
                            fetchedMovies = try await TMDBService.shared.fetchRecommendations(
                                includeGenres: [val], excludeGenres: [27, 53, 80],
                                page: Int.random(in: 1...3)
                            )
                        }
                        else {
                            fetchedMovies = try await TMDBService.shared.fetchRecommendations(
                                includeGenres: [val], excludeGenres: [],
                                page: Int.random(in: 1...3)
                            )
                        }
                    }
                    
                case .keyword:
                    fetchedMovies = try await TMDBService.shared.fetchRecommendations(
                        includeGenres: [], excludeGenres: [],
                        withKeywords: category.value,
                        page: Int.random(in: 1...3)
                    )
                    
                case .language:
                    fetchedMovies = try await TMDBService.shared.fetchRecommendations(
                        includeGenres: [], excludeGenres: [],
                        withOriginalLanguage: category.value,
                        page: Int.random(in: 1...3)
                    )
                }
                
                let tagName = NSLocalizedString(category.name, comment: "")
                var combined: [Movie] = []
                for m in fetchedMovies { combined.append(self.addReason(m, tagName)) }
                
                if combined.isEmpty {
                    self.errorMessage = "è¯¥åˆ†ç±»æš‚æ—¶æ²¡æœ‰æ›´å¤šå½±ç‰‡"
                } else {
                    processAndAssignMovies(combined, currentSeen: currentSeen, currentWatch: currentWatch, reset: reset)
                }
                
            } catch { if reset { self.errorMessage = localized("ç½‘ç»œä¸ä½³ï¼Œæ— æ³•è·å–è¯¥ç±»å½±ç‰‡") } }
        } else {
            await performSmartRecommendation(reset: reset, currentSeen: currentSeen, currentWatch: currentWatch)
        }
    }
    
    private func performSmartRecommendation(reset: Bool, currentSeen: Set<Int>, currentWatch: [Int]) async {
        let scores = genreScores
        let hatedGenres = scores.filter { $0.value <= -5 }.map { $0.key }
        let topGenreIds = scores.filter { $0.value > 0 }.sorted { $0.value > $1.value }.prefix(3).map { $0.key }
        let favoriteGenreId = topGenreIds.first
        
        let recentLikes = likedMovies
        let toWatch = toWatchList
        
        let seedMovie = recentLikes.prefix(5).randomElement()?.toMovie
        var seedTitle = ""
        if let s = seedMovie { seedTitle = s.title.count > 6 ? String(s.title.prefix(5)) + "..." : s.title }
        
        let currentSeenCount = seenCount
        
        do {
            async let slotSimilar = (seedMovie != nil) ? (try? await TMDBService.shared.fetchSimilarMovies(movieId: seedMovie!.id))?.prefix(2).map{addReason($0, localized("ç±»ä¼¼ã€Š%@ã€‹", seedTitle))} ?? [] : []
            
            async let slotPerson: [Movie] = {
                let seedPool = (recentLikes.prefix(5).map { $0.toMovie } + toWatch.prefix(5))
                guard let seed = seedPool.randomElement() else { return [] }
                guard let credits = try? await TMDBService.shared.fetchCredits(movieId: seed.id) else { return [] }
                
                let genreFilter = topGenreIds.isEmpty ? [] : [topGenreIds.first!]
                
                let useDirector = Bool.random()
                if useDirector, let director = credits.crew.first(where: { $0.job == "Director" }) {
                    return (try? await TMDBService.shared.fetchRecommendations(
                        includeGenres: genreFilter,
                        excludeGenres: hatedGenres,
                        withPeople: [director.id],
                        page: 1
                    ))?.prefix(2).map { addReason($0, localized("%@ Â· é£æ ¼ç²¾é€‰", director.name)) } ?? []
                } else if let actor = credits.cast.first {
                    return (try? await TMDBService.shared.fetchRecommendations(
                        includeGenres: genreFilter,
                        excludeGenres: hatedGenres,
                        withPeople: [actor.id],
                        page: 1
                    ))?.prefix(2).map { addReason($0, localized("%@ Â· é£æ ¼ç²¾é€‰", actor.name)) } ?? []
                }
                return []
            }()
            
            async let slotFavoriteGenre: [Movie] = {
                guard let favId = favoriteGenreId else { return [] }
                
                let estimatedPage = (currentSeenCount / 20) + 1
                let queryPage = Int.random(in: 1...max(3, estimatedPage + 2))
                
                let results = (try? await TMDBService.shared.fetchRecommendations(
                    includeGenres: [favId],
                    excludeGenres: hatedGenres,
                    sortBy: "vote_average.desc",
                    minVoteCount: 1000,
                    page: queryPage
                ))?.prefix(3) ?? []
                
                return results.map { m in
                    if let score = m.voteAverage, score >= 8.5 { return addReason(m, localized("å£ç¢‘ç¥ä½œ")) }
                    else if let votes = m.voteCount, votes < 3000 { return addReason(m, localized("å†·é—¨ä½³ç‰‡")) }
                    else { return addReason(m, localized("é«˜åˆ†ç²¾é€‰")) }
                }
            }()
            
            let selectedLangs = worldLanguages.shuffled().prefix(5)
            var mixedWorldMovies: [Movie] = []
            
            await withTaskGroup(of: [Movie].self) { group in
                for lang in selectedLangs {
                    group.addTask {
                        let res = try? await TMDBService.shared.fetchRecommendations(
                            includeGenres: [], excludeGenres: hatedGenres,
                            withOriginalLanguage: lang, minVoteCount: 300,
                            page: Int.random(in: 1...2)
                        )
                        let raw = res ?? []
                        let langName = Locale.current.localizedString(forIdentifier: lang) ?? "å¤–è¯­"
                        return raw.prefix(2).map { self.addReason($0, self.localized("é«˜åˆ† Â· %@", langName)) }
                    }
                }
                for await movies in group {
                    mixedWorldMovies.append(contentsOf: movies)
                }
            }
            mixedWorldMovies.shuffle()
            
            async let slotChinese = try? await TMDBService.shared.fetchRecommendations(includeGenres: [], excludeGenres: hatedGenres, withOriginalLanguage: "zh", page: Int.random(in: 1...5))
            
            let (rSimilar, rPerson, rFavorite, rChinese) = await (slotSimilar, slotPerson, slotFavoriteGenre, slotChinese ?? [])
            
            var combined: [Movie] = []
            combined.append(contentsOf: rFavorite)
            combined.append(contentsOf: rSimilar)
            combined.append(contentsOf: rPerson)
            combined.append(contentsOf: rChinese.prefix(3).map { addReason($0, localized("çƒ­é—¨åè¯­")) })
            combined.append(contentsOf: mixedWorldMovies)
            
            processAndAssignMovies(combined, currentSeen: currentSeen, currentWatch: currentWatch, reset: reset)
        } catch {}
    }
    
    func loadOnboardingMovies() async {
        isLoading = true; errorMessage = nil;
        defer { isLoading = false }
        
        async let tTopRated = (try? await TMDBService.shared.fetchRecommendations(includeGenres: [], excludeGenres: [], sortBy: "vote_average.desc", minVoteCount: 3000, page: 1)) ?? []
        async let tPopular = (try? await TMDBService.shared.fetchRecommendations(includeGenres: [], excludeGenres: [], sortBy: "popularity.desc", minVoteCount: 1000, page: Int.random(in: 1...5))) ?? []
        async let tChinese = (try? await TMDBService.shared.fetchRecommendations(includeGenres: [], excludeGenres: [], withOriginalLanguage: "zh", sortBy: "vote_average.desc", minVoteCount: 500, page: 1)) ?? []
        
        let (rTop, rPop, rChinese) = await (tTopRated, tPopular, tChinese)
        let mixed = (rTop + rPop + rChinese).filter { isValidMovie($0) }
        
        if mixed.isEmpty { self.errorMessage = localized("åˆå§‹åŒ–å¤±è´¥"); return }
        let processed = mixed.map { self.addReason($0, $0.genresString) }
        self.onboardingMovies = Array(Set(processed)).shuffled().prefix(50).map { $0 }
    }
    
    func completeOnboardingEarly() { completeOnboarding() }
    private func completeOnboarding() { isLoading = true; appState = .dashboard; Task { await refreshRecommendations() } }
    nonisolated private func addReason(_ movie: Movie, _ reason: String) -> Movie { var m = movie; m.recommendationReason = reason; return m }
    
    nonisolated private func generateBasicInfo(for movie: Movie) -> String {
        var tags: [String] = []
        if let score = movie.voteAverage, score > 0 { tags.append(String(format: "%.1fåˆ†", score)) }
        let region = !movie.countryString.isEmpty ? movie.countryString : movie.languageString
        if !region.isEmpty { tags.append(region) }
        return tags.joined(separator: " Â· ")
    }
    
    private func isValidMovie(_ movie: Movie) -> Bool {
        if movie.overview.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty { return false }
        if movie.isAdult { return false }
        if selectedCategory?.value == "upcoming" { return true }
        
        if let score = movie.voteAverage, score < 4.0 { return false }
        if let votes = movie.voteCount, votes < 50 { return false }
        if let gIds = movie.genreIds, !bannedGenres.isDisjoint(with: gIds) { return false }
        let titleLower = movie.title.lowercased()
        for keyword in bannedTitleKeywords { if titleLower.contains(keyword) { return false } }
        return true
    }
    func resetApp() { try? modelContext?.delete(model: SavedMovie.self); appState = .onboarding; Task { await loadOnboardingMovies() } }
    func retry() { errorMessage = nil; if appState == .onboarding { Task { await loadOnboardingMovies() } } else { Task { await refreshRecommendations() } } }
    
    private func checkAndAskForReview() {
            if [20, 50, 100].contains(likedMovieIds.count) { requestReview() }
        }
        
        func requestReview() {
            #if os(iOS)
            DispatchQueue.main.asyncAfter(deadline: .now()+1.0) {
                if let s = UIApplication.shared.connectedScenes.first as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: s)
                }
            }
            #endif
        }
    
    nonisolated private func localized(_ key: String, _ args: CVarArg...) -> String {
        let format = NSLocalizedString(key, comment: "")
        if args.isEmpty { return format }
        return String(format: format, arguments: args)
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/DirectorMoviesView.swift
// ==========================================

//
//  DirectorMoviesView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SDWebImageSwiftUI

struct DirectorMoviesView: View {
    let director: Person // å…¶å®è¿™é‡Œå¯ä»¥æ˜¯ä»»ä½•å½±äººï¼Œå˜é‡åä¿ç•™ director æ²¡å…³ç³»
    @EnvironmentObject var viewModel: AppViewModel
    @State private var movies: [Movie] = []
    @State private var isLoading = true
    
    var body: some View {
        VStack {
            if isLoading {
                ProgressView()
            } else if movies.isEmpty {
                VStack(spacing: 10) {
                    Image(systemName: "film")
                        .font(.largeTitle)
                        .foregroundColor(.gray)
                    Text("æš‚æ— æ”¶å½•ä½œå“")
                        .foregroundColor(.secondary)
                }
                .padding(.top, 50)
                Spacer()
            } else {
                List(movies) { movie in
                    NavigationLink(destination: MovieDetailView(movie: movie)) {
                        HStack(alignment: .top, spacing: 12) {
                            WebImage(url: movie.thumbnailURL)
                                .resizable()
                                .indicator(.activity)
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 60, height: 90)
                                .cornerRadius(6)
                                .clipped()
                            
                            VStack(alignment: .leading, spacing: 6) {
                                Text(movie.title)
                                    .font(.headline)
                                    .lineLimit(2)
                                
                                HStack {
                                    // ğŸŸ¢ ä¼˜å…ˆæ˜¾ç¤ºå…·ä½“çš„èŒä½æ ‡ç­¾ (å¯¼æ¼”/ç¼–å‰§/ç›‘åˆ¶)
                                    if let reason = movie.recommendationReason, !reason.isEmpty {
                                        Text(reason)
                                            .font(.caption)
                                            .fontWeight(.bold)
                                            .foregroundColor(.white)
                                            .padding(.horizontal, 6)
                                            .padding(.vertical, 2)
                                            .background(Color.blue.opacity(0.8))
                                            .cornerRadius(4)
                                    }
                                    
                                    Text(movie.year)
                                        .font(.subheadline)
                                        .foregroundColor(.secondary)
                                }
                                
                                HStack {
                                    if let score = movie.voteAverage {
                                        Text(String(format: "%.1fåˆ†", score))
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.orange)
                                        Text("Â·")
                                            .foregroundColor(.secondary)
                                    }
                                    Text(movie.infoString)
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                        .lineLimit(1)
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                }
                .listStyle(.plain)
            }
        }
        .navigationTitle(director.name)
        .navigationBarTitleDisplayMode(.inline)
        .task {
            do {
                // ä½¿ç”¨æ–°çš„ã€ç²¾ç¡®çš„è·å–æ–¹æ³•
                self.movies = try await viewModel.fetchPersonWorks(personId: director.id)
            } catch {
                print("Failed to load person works: \(error)")
            }
            self.isLoading = false
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/TMDBService.swift
// ==========================================

//
//  TMDBService.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//

import Foundation

class TMDBService {
    static let shared = TMDBService()
    
    private var apiKey: String {
        let part1 = "b8b948c05d8b5"
        let part2 = "b1e760f070e74050b88"
        return part1 + part2
    }
    
    // ğŸŸ¢ æ™ºèƒ½è®¡ç®— baseURL
        private var baseURL: String {
            // 1. è·å–ç”¨æˆ·å½“å‰çš„åœ°åŒºä»£ç  (å¦‚ "CN", "US", "JP")
            let regionCode = Locale.current.region?.identifier ?? "US"
            
            // 2. åˆ¤æ–­é€»è¾‘
            if regionCode == "CN" {
                // ğŸ‡¨ğŸ‡³ ä¸­å›½å¤§é™†ç”¨æˆ·ï¼šèµ°ä½ çš„å¤§é™†ä¸­è½¬æœåŠ¡å™¨
                // ä¼˜åŠ¿ï¼šè¿‡å¢™ï¼Œç¨³å®š
                return "https://api.kinotaste.me/3"
            } else {
                return "https://api.kinotaste.me/3"
            }
        }
    
    static let genreMap: [Int: String] = [
        28: "åŠ¨ä½œ", 12: "å†’é™©", 16: "åŠ¨ç”»", 35: "å–œå‰§", 80: "çŠ¯ç½ª",
        99: "çºªå½•", 18: "å‰§æƒ…", 10751: "å®¶åº­", 14: "å¥‡å¹»", 36: "å†å²",
        27: "ææ€–", 10402: "éŸ³ä¹", 9648: "æ‚¬ç–‘", 10749: "çˆ±æƒ…", 878: "ç§‘å¹»",
        10770: "ç”µè§†ç”µå½±", 53: "æƒŠæ‚š", 10752: "æˆ˜äº‰", 37: "è¥¿éƒ¨"
    ]
    
    private var apiLanguage: String {
        let identifier = Locale.current.identifier
        if identifier.contains("Hant") || identifier.contains("TW") || identifier.contains("HK") || identifier.contains("MO") {
            return "zh-TW"
        }
        return "zh-CN"
    }
    
    // MARK: - æ ¸å¿ƒè¯·æ±‚æ–¹æ³•
    private func fetch<T: Decodable>(endpoint: String, params: [String: String] = [:]) async throws -> T {
        guard var components = URLComponents(string: baseURL + endpoint) else { throw URLError(.badURL) }
        var queryItems = [
            URLQueryItem(name: "api_key", value: apiKey)
        ]
        
        if endpoint.contains("/images") {
             queryItems.append(URLQueryItem(name: "include_image_language", value: "null,en,zh"))
        } else {
             queryItems.append(URLQueryItem(name: "language", value: apiLanguage))
        }
        
        for (key, value) in params { queryItems.append(URLQueryItem(name: key, value: value)) }
        components.queryItems = queryItems
        guard let url = components.url else { throw URLError(.badURL) }
        let (data, response) = try await URLSession.shared.data(from: url)
        if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
            print("âŒ API è¯·æ±‚å¤±è´¥: \(httpResponse.statusCode) - URL: \(url.absoluteString)")
        }
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    // MARK: - ä¸šåŠ¡æ¥å£
    
    func fetchDiscovery(page: Int = 1) async throws -> [Movie] {
        let response: TMDBResponse = try await fetch(endpoint: "/movie/popular", params: [
            "page": "\(page)",
            "include_adult": "false"
        ])
        return response.results
    }
    
    // ğŸŸ¢ Revert: ä¸å†è·å– keywords
    func fetchMovieDetails(movieId: Int) async throws -> Movie {
        return try await fetch(endpoint: "/movie/\(movieId)")
    }
    
    func fetchImages(movieId: Int) async throws -> [MovieImage] {
        let response: MovieImageResponse = try await fetch(endpoint: "/movie/\(movieId)/images")
        return response.backdrops
    }
    
    func fetchSimilarMovies(movieId: Int) async throws -> [Movie] {
        let response: TMDBResponse = try await fetch(endpoint: "/movie/\(movieId)/recommendations", params: [
            "include_adult": "false"
        ])
        return response.results
    }
    
    func fetchMovieKeywords(movieId: Int) async throws -> [Keyword] {
        let response: KeywordResponse = try await fetch(endpoint: "/movie/\(movieId)/keywords")
        return response.keywords
    }
    
    func fetchList(listId: String, page: Int = 1) async throws -> [Movie] {
        struct ListResponse: Codable { let items: [Movie] }
        let response: ListResponse = try await fetch(endpoint: "/list/\(listId)", params: ["page": "\(page)"])
        return response.items
    }
    
    func fetchRecommendations(
        includeGenres: [Int],
        excludeGenres: [Int],
        withPeople: [Int]? = nil,
        withCompanies: String? = nil,
        withOriginalLanguage: String? = nil,
        withKeywords: String? = nil,
        withoutKeywords: String? = nil,
        releaseDateGte: String? = nil,
        releaseDateLte: String? = nil,
        sortBy: String = "popularity.desc",
        minVoteCount: Int? = nil,
        page: Int = 1
    ) async throws -> [Movie] {
        
        let includeStr = includeGenres.map { String($0) }.joined(separator: ",")
        let excludeStr = excludeGenres.map { String($0) }.joined(separator: ",")
        
        var params: [String: String] = [
            "sort_by": sortBy,
            "include_adult": "false",
            "page": "\(page)"
        ]
        
        if !includeStr.isEmpty { params["with_genres"] = includeStr }
        if !excludeStr.isEmpty { params["without_genres"] = excludeStr }
        
        if let people = withPeople, !people.isEmpty {
            params["with_people"] = people.map { String($0) }.joined(separator: ",")
        }
        
        if let companies = withCompanies { params["with_companies"] = companies }
        
        if let dateGte = releaseDateGte { params["primary_release_date.gte"] = dateGte }
        if let dateLte = releaseDateLte { params["primary_release_date.lte"] = dateLte }
        
        if let lang = withOriginalLanguage { params["with_original_language"] = lang }
        
        if let keywords = withKeywords { params["with_keywords"] = keywords }
        if let noKeywords = withoutKeywords { params["without_keywords"] = noKeywords }
        
        if let minVotes = minVoteCount { params["vote_count.gte"] = String(minVotes) }
        
        let response: TMDBResponse = try await fetch(endpoint: "/discover/movie", params: params)
        return response.results
    }
    
    func fetchPersonCredits(personId: Int) async throws -> PersonCreditResponse {
        return try await fetch(endpoint: "/person/\(personId)/movie_credits")
    }
    
    func searchMovies(query: String, page: Int = 1) async throws -> [Movie] {
        let response: TMDBResponse = try await fetch(endpoint: "/search/movie", params: [
            "query": query, "page": "\(page)", "include_adult": "false"
        ])
        return response.results
    }
    
    func fetchCredits(movieId: Int) async throws -> CreditsResponse {
        return try await fetch(endpoint: "/movie/\(movieId)/credits")
    }

    func fetchVideos(movieId: Int) async throws -> [Video] {
        let response: VideoResponse = try await fetch(endpoint: "/movie/\(movieId)/videos")
        return response.results
    }
    
    func searchPeople(query: String) async throws -> [Person] {
        let response: TMDBPersonResponse = try await fetch(endpoint: "/search/person", params: ["query": query, "include_adult": "false"])
        return response.results
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/HistoryView.swift
// ==========================================

//
//  HistoryView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/5.
//
import SwiftUI
import SwiftData
import SDWebImageSwiftUI

struct HistoryView: View {
    // æŸ¥è¯¢æ‰€æœ‰äº¤äº’è¿‡çš„ç”µå½±ï¼ŒæŒ‰æ—¶é—´å€’åº
    @Query(filter: #Predicate<SavedMovie> { $0.isLiked || $0.isDisliked || $0.isNeutral || $0.isWatched },
           sort: [SortDescriptor(\.interactionDate, order: .reverse)])
    private var history: [SavedMovie]
    
    // æŒ‰æœˆä»½åˆ†ç»„
    var groupedHistory: [String: [SavedMovie]] {
        Dictionary(grouping: history) { movie in
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyyå¹´Mæœˆ" // ä¾‹å¦‚ï¼š2026å¹´1æœˆ
            return formatter.string(from: movie.interactionDate)
        }
    }
    
    // è·å–æ’åºåçš„æœˆä»½é”®å€¼
    var sortedMonths: [String] {
        groupedHistory.keys.sorted { dateStr1, dateStr2 in
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyyå¹´Mæœˆ"
            return (formatter.date(from: dateStr1) ?? Date()) > (formatter.date(from: dateStr2) ?? Date())
        }
    }
    
    var body: some View {
        List {
            if history.isEmpty {
                VStack(spacing: 15) {
                    Image(systemName: "clock.arrow.circlepath")
                        .font(.largeTitle)
                        .foregroundColor(.gray)
                    Text("æš‚æ— è¶³è¿¹")
                        .foregroundColor(.secondary)
                    Text("ä½ çœ‹è¿‡çš„ã€è¯„ä»·è¿‡çš„ç”µå½±éƒ½ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.top, 50)
                .listRowBackground(Color.clear)
            } else {
                ForEach(sortedMonths, id: \.self) { month in
                    Section(header: Text(month).font(.headline)) {
                        ForEach(groupedHistory[month] ?? []) { item in
                            NavigationLink(destination: MovieDetailView(movie: item.toMovie)) {
                                HistoryRow(item: item)
                            }
                        }
                    }
                }
            }
        }
        .listStyle(.insetGrouped)
        .navigationTitle("è§‚å½±è¶³è¿¹")
    }
}

// è¶³è¿¹å•è¡Œè§†å›¾
struct HistoryRow: View {
    let item: SavedMovie
    
    var body: some View {
        HStack(spacing: 12) {
            // æ—¶é—´ç‚¹
            VStack {
                Text(dayString(from: item.interactionDate))
                    .font(.title3).bold()
                    .foregroundColor(.primary)
                Text(timeString(from: item.interactionDate))
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            .frame(width: 40)
            
            // å°æµ·æŠ¥
            WebImage(url: item.toMovie.thumbnailURL)
                .resizable()
                .indicator(.activity)
                .aspectRatio(contentMode: .fill)
                .frame(width: 40, height: 60)
                .cornerRadius(4)
                .clipped()
            
            // ä¿¡æ¯
            VStack(alignment: .leading, spacing: 4) {
                Text(item.title)
                    .font(.subheadline).bold()
                    .lineLimit(1)
                
                HStack(spacing: 6) {
                    statusBadge(item)
                    if let score = item.voteAverage, score > 0 {
                        Text("\(String(format: "%.1f", score))åˆ†")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }
                }
            }
        }
        .padding(.vertical, 4)
    }
    
    // çŠ¶æ€å¾½ç« 
    @ViewBuilder
    func statusBadge(_ item: SavedMovie) -> some View {
        if item.isLiked {
            Label("å–œæ¬¢", systemImage: "heart.fill").font(.caption2).foregroundColor(.red)
        } else if item.isDisliked {
            Label("ä¸å–œæ¬¢", systemImage: "hand.thumbsdown.fill").font(.caption2).foregroundColor(.gray)
        } else if item.isNeutral {
            Label("ä¸€èˆ¬", systemImage: "face.smiling").font(.caption2).foregroundColor(.blue)
        } else {
            Label("çœ‹è¿‡", systemImage: "eye").font(.caption2).foregroundColor(.secondary)
        }
    }
    
    func dayString(from date: Date) -> String {
        let f = DateFormatter(); f.dateFormat = "dd"; return f.string(from: date)
    }
    func timeString(from date: Date) -> String {
        let f = DateFormatter(); f.dateFormat = "HH:mm"; return f.string(from: date)
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/KinoTasteApp.swift
// ==========================================

//
//  KinoTasteApp.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SwiftData
import SDWebImageSwiftUI

@main
struct KinoTasteApp: App {
    @StateObject var viewModel = AppViewModel()
    
    let container: ModelContainer
    
    init() {
        let cache = SDImageCache.shared
        cache.config.maxDiskSize = 100 * 1024 * 1024
        cache.config.maxMemoryCost = 20 * 1024 * 1024
        cache.config.diskCacheExpireType = .accessDate
        cache.config.maxDiskAge = 60 * 60 * 24 * 7

        do {
            container = try ModelContainer(for: SavedMovie.self)
        } catch {
            fatalError("Failed to create ModelContainer: \(error)")
        }
    }
    
    var body: some Scene {
        WindowGroup {
            ZStack {
                // ğŸŸ¢ éšç§åˆè§„æ‹¦æˆªå±‚ï¼šæœªåŒæ„å‰ï¼Œæ˜¾ç¤ºåè®®é¡µ
                if !viewModel.hasAgreedPrivacy {
                    PrivacyAgreementView(viewModel: viewModel)
                        .zIndex(3.0)
                        .transition(.opacity)
                } else {
                    // ä¸»æµç¨‹
                    Group {
                        if viewModel.appState == .onboarding {
                            OnboardingView(viewModel: viewModel)
                        } else {
                            MainView(viewModel: viewModel)
                                .environmentObject(viewModel)
                        }
                    }
                    
                    // å¯åŠ¨é¡µè¦†ç›–
                    if viewModel.showSplash {
                        SplashView()
                            .transition(.opacity)
                            .zIndex(2.0)
                    }
                }
            }
            .animation(.easeInOut(duration: 0.5), value: viewModel.showSplash)
            .animation(.easeInOut(duration: 0.3), value: viewModel.hasAgreedPrivacy)
            .background(ContextSetter(viewModel: viewModel))
            .modelContainer(container)
        }
    }
}

// è¾…åŠ©è§†å›¾
struct ContextSetter: View {
    @Environment(\.modelContext) var context
    var viewModel: AppViewModel
    
    var body: some View {
        Color.clear
            .onAppear {
                viewModel.setContext(context)
            }
    }
}

// å…¨å±€å¯ç”¨ä¾§æ»‘è¿”å›
extension UINavigationController: UIGestureRecognizerDelegate {
    override open func viewDidLoad() {
        super.viewDidLoad()
        interactivePopGestureRecognizer?.delegate = self
    }
    
    public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
        return viewControllers.count > 1
    }
}

// MARK: - ğŸŸ¢ éšç§æ”¿ç­–å¼¹çª—ç»„ä»¶
struct PrivacyAgreementView: View {
    @ObservedObject var viewModel: AppViewModel
    
    // âš ï¸ æ³¨æ„ï¼šè¿™é‡Œæš‚æ—¶ä½¿ç”¨äº†æ‚¨çš„ Notion é“¾æ¥
    // å»ºè®®ä¸Šçº¿å‰å°†å†…å®¹è¿ç§»è‡³æ‚¨è‡ªå·±çš„æœåŠ¡å™¨ (api.kinotaste.online/privacy.html)
    private let privacyURL = URL(string: "https://api.kinotaste.online/privacy.html")!
    
    var body: some View {
        ZStack {
            Color(UIColor.systemBackground).ignoresSafeArea()
            
            VStack(spacing: 24) {
                Spacer()
                
                Image(systemName: "hand.raised.fill")
                    .font(.system(size: 60))
                    .foregroundColor(.blue)
                    .padding(.bottom, 10)
                
                Text("æ¬¢è¿ä½¿ç”¨ä»Šå¤©çœ‹ä»€ä¹ˆ")
                    .font(.title2.bold())
                
                VStack(spacing: 8) {
                    Text("åœ¨å¼€å§‹æ¢ç´¢ç”µå½±ä¸–ç•Œä¹‹å‰ï¼Œè¯·æ‚¨ä»”ç»†é˜…è¯»å¹¶åŒæ„æˆ‘ä»¬çš„éšç§æ”¿ç­–ã€‚")
                        .font(.body)
                        .multilineTextAlignment(.center)
                        .foregroundColor(.secondary)
                    
                    Text("æˆ‘ä»¬å°†ä¸¥æ ¼ä¿æŠ¤æ‚¨çš„ä¸ªäººä¿¡æ¯å®‰å…¨ï¼Œä»…åœ¨æ‚¨åŒæ„çš„æƒ…å†µä¸‹æ”¶é›†å¿…è¦çš„è§‚å½±åå¥½æ•°æ®ä»¥æä¾›æ¨èæœåŠ¡ã€‚")
                        .font(.caption)
                        .multilineTextAlignment(.center)
                        .foregroundColor(.gray)
                }
                .padding(.horizontal, 30)
                
                // éšç§æ”¿ç­–é“¾æ¥
                Link("ã€Šéšç§æ”¿ç­–ã€‹", destination: privacyURL)
                    .font(.headline)
                    .foregroundColor(.blue)
                    .padding(.vertical, 10)
                
                Spacer()
                
                Button(action: {
                    withAnimation {
                        viewModel.agreePrivacy()
                    }
                }) {
                    Text("åŒæ„å¹¶ç»§ç»­")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .cornerRadius(16)
                        .shadow(color: .blue.opacity(0.3), radius: 5, y: 3)
                }
                .padding(.horizontal, 24)
                .padding(.bottom, 50)
            }
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/MainView.swift
// ==========================================

//
//  MainView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI
import SDWebImageSwiftUI

struct MainView: View {
    @ObservedObject var viewModel: AppViewModel
    @State private var showSearch = false
    @State private var showCategorySheet = false
    @State private var showInspiration = false
    
    // ğŸŸ¢ å®šä¹‰ä½é¥±å’Œåº¦é»„è‰² (Cream/Champagne)
    private let mutedYellow = Color(red: 0.92, green: 0.85, blue: 0.55)
    
    var body: some View {
        TabView {
            NavigationView {
                ZStack(alignment: .bottomTrailing) {
                    VStack(spacing: 0) {
                        
                        // ä½¿ç”¨ ScrollViewReader åŒ…è£¹å†…å®¹ä»¥æ”¯æŒç¨‹åºåŒ–æ»šåŠ¨
                        ScrollViewReader { scrollProxy in
                            
                            // MARK: - 1. é¡¶éƒ¨ Header
                            VStack(spacing: 15) {
                                HStack(alignment: .center) {
                                    Text("å‘ç°")
                                        .font(.system(size: 34, weight: .bold, design: .rounded))
                                        .foregroundColor(.primary)
                                    
                                    Spacer()
                                    
                                    // çµæ„ŸæŒ‰é’®
                                    if !viewModel.isLoading {
                                        Button(action: { showInspiration = true }) {
                                            HStack(spacing: 4) {
                                                Image(systemName: "bolt.fill")
                                                    .font(.system(size: 14))
                                                Text("çµæ„Ÿ")
                                                    .font(.system(size: 14, weight: .bold))
                                            }
                                            .foregroundColor(mutedYellow)
                                            .padding(.vertical, 6)
                                            .padding(.horizontal, 12)
                                            .background(Color.black)
                                            .clipShape(Capsule())
                                            .overlay(
                                                Capsule()
                                                    .stroke(mutedYellow, lineWidth: 1)
                                            )
                                            .shadow(color: Color.black.opacity(0.15), radius: 4, x: 0, y: 2)
                                        }
                                        .transition(.scale.combined(with: .opacity))
                                        .padding(.trailing, 8)
                                    }
                                    
                                    // åˆ·æ–°æŒ‰é’®
                                    Button(action: {
                                        Task {
                                            let previousCount = viewModel.recommendedMovies.count
                                            await viewModel.refreshRecommendations(reset: false)
                                            
                                            if viewModel.recommendedMovies.count > previousCount {
                                                let firstNewMovie = viewModel.recommendedMovies[previousCount]
                                                try? await Task.sleep(nanoseconds: 100_000_000)
                                                withAnimation(.spring()) {
                                                    scrollProxy.scrollTo(firstNewMovie.id, anchor: .top)
                                                }
                                            }
                                        }
                                    }) {
                                        Group {
                                            if viewModel.isLoading {
                                                ProgressView().tint(.primary)
                                            } else {
                                                Image(systemName: "arrow.clockwise")
                                                    .font(.system(size: 20, weight: .semibold))
                                                    .foregroundColor(.primary)
                                            }
                                        }
                                        .frame(width: 20, height: 20)
                                        .padding(10)
                                        .background(Color(UIColor.secondarySystemGroupedBackground))
                                        .clipShape(Circle())
                                        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
                                    }
                                    .disabled(viewModel.isLoading)
                                    .padding(.trailing, 8)
                                    
                                    // æœç´¢æŒ‰é’®
                                    Button(action: { showSearch = true }) {
                                        Image(systemName: "magnifyingglass")
                                            .font(.system(size: 20, weight: .semibold))
                                            .foregroundColor(.primary)
                                            .padding(10)
                                            .background(Color(UIColor.secondarySystemGroupedBackground))
                                            .clipShape(Circle())
                                            .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
                                    }
                                }
                                .padding(.horizontal)
                                .padding(.top, 10)
                                
                                // åŒæŒ‰é’®å¯¼èˆª
                                HStack(spacing: 12) {
                                    SelectionButton(
                                        title: "âœ¨ çŒœä½ å–œæ¬¢",
                                        isSelected: viewModel.selectedCategory == nil
                                    ) {
                                        Task {
                                            await viewModel.changeCategory(to: nil)
                                            withAnimation { scrollProxy.scrollTo("TOP_ANCHOR", anchor: .top) }
                                        }
                                    }
                                    
                                    SelectionButton(
                                        title: viewModel.selectedCategory?.name ?? "ğŸï¸ åˆ†ç±»èƒ¶å·",
                                        isSelected: viewModel.selectedCategory != nil,
                                        isExpandable: true
                                    ) {
                                        showCategorySheet = true
                                    }
                                }
                                .padding(.horizontal)
                                .padding(.bottom, 10)
                            }
                            .background(Color(UIColor.systemBackground))
                            .shadow(color: Color.black.opacity(0.03), radius: 5, y: 5)
                            .zIndex(1)
                            
                            // MARK: - 2. ç”µå½±åˆ—è¡¨å†…å®¹
                            if viewModel.isLoading && viewModel.recommendedMovies.isEmpty {
                                Spacer()
                                VStack(spacing: 15) {
                                    ProgressView().scaleEffect(1.2)
                                    Text("æ­£åœ¨å†²æ´—èƒ¶ç‰‡...").font(.caption).foregroundColor(.secondary)
                                }
                                Spacer()
                            } else if let error = viewModel.errorMessage {
                                Spacer()
                                ErrorView(errorText: error) { viewModel.retry() }
                                Spacer()
                            } else {
                                ScrollView {
                                    Color.clear.frame(height: 1).id("TOP_ANCHOR")
                                    
                                    LazyVStack(spacing: 24) {
                                        ForEach(viewModel.recommendedMovies) { movie in
                                            NavigationLink(destination: MovieDetailView(movie: movie)) {
                                                MovieCardView(movie: movie, isDetailMode: .constant(false))
                                                    .padding(.horizontal)
                                                    // ğŸŸ¢ æ·»åŠ é•¿æŒ‰èœå• (Context Menu)
                                                    .contextMenu {
                                                        // 1. å¾…çœ‹
                                                        Button {
                                                            viewModel.toggleWatchlistContext(movie)
                                                        } label: {
                                                            let isAdded = viewModel.isMovieToWatch(movie.id)
                                                            Label(isAdded ? "ç§»å‡ºå¾…çœ‹" : "åŠ å…¥å¾…çœ‹", systemImage: isAdded ? "bookmark.fill" : "bookmark")
                                                        }
                                                        
                                                        Divider()
                                                        
                                                        // 2. å–œæ¬¢
                                                        Button {
                                                            viewModel.rateMovie(movie: movie, type: .like)
                                                        } label: {
                                                            Label("å–œæ¬¢", systemImage: "heart")
                                                        }
                                                        
                                                        // 3. ä¸€èˆ¬
                                                        Button {
                                                            viewModel.rateMovie(movie: movie, type: .neutral)
                                                        } label: {
                                                            Label("ä¸€èˆ¬", systemImage: "face.smiling")
                                                        }
                                                        
                                                        // 4. ä¸å–œæ¬¢
                                                        Button {
                                                            viewModel.rateMovie(movie: movie, type: .dislike)
                                                        } label: {
                                                            Label("ä¸å–œæ¬¢", systemImage: "hand.thumbsdown")
                                                        }
                                                        
                                                        // 5. ä¸æƒ³çœ‹
                                                        Button(role: .destructive) {
                                                            viewModel.rateMovie(movie: movie, type: .notInterested)
                                                        } label: {
                                                            Label("ä¸æƒ³çœ‹", systemImage: "eye.slash")
                                                        }
                                                        
                                                    } preview: {
                                                        // ğŸŸ¢ ä½¿ç”¨çº¯æµ·æŠ¥é¢„è§ˆ
                                                        MovieContextMenuPreview(movie: movie)
                                                    }
                                            }
                                            .buttonStyle(PlainButtonStyle())
                                            .id(movie.id)
                                        }
                                        
                                        // åº•éƒ¨æŒ‰é’®
                                        Button(action: {
                                            Task {
                                                let previousCount = viewModel.recommendedMovies.count
                                                await viewModel.refreshRecommendations(reset: false)
                                                
                                                if viewModel.recommendedMovies.count > previousCount {
                                                    let firstNewMovie = viewModel.recommendedMovies[previousCount]
                                                    try? await Task.sleep(nanoseconds: 100_000_000)
                                                    withAnimation(.spring()) {
                                                        scrollProxy.scrollTo(firstNewMovie.id, anchor: .top)
                                                    }
                                                }
                                            }
                                        }) {
                                            HStack {
                                                if viewModel.isLoading {
                                                    ProgressView().tint(.blue).padding(.trailing, 5)
                                                    Text("æ­£åœ¨åŠ è½½...")
                                                } else {
                                                    Image(systemName: "arrow.clockwise")
                                                    Text("æ¢ä¸€æ‰¹è¯•è¯•")
                                                }
                                            }
                                            .font(.headline)
                                            .foregroundColor(.blue)
                                            .padding(.vertical, 16)
                                            .frame(maxWidth: .infinity)
                                            .background(Color(UIColor.secondarySystemBackground))
                                            .cornerRadius(16)
                                            .padding(.horizontal)
                                            .padding(.bottom, 30)
                                            .opacity(viewModel.isLoading ? 0.6 : 1.0)
                                        }
                                        .disabled(viewModel.isLoading)
                                    }
                                    .padding(.top, 20)
                                    
                                    Color.clear.frame(height: 1).id("BOTTOM_ANCHOR")
                                }
                                .animation(.spring(response: 0.5, dampingFraction: 0.8), value: viewModel.recommendedMovies)
                            }
                        }
                    }
                    .navigationBarHidden(true)
                    .background(Color(UIColor.systemGroupedBackground))
                }
            }
            .navigationViewStyle(StackNavigationViewStyle())
            .tabItem { Label("æ¨è", systemImage: "film.stack") }
            .sheet(isPresented: $showSearch) { SearchView(viewModel: viewModel) }
            .sheet(isPresented: $showCategorySheet) {
                FilmRollView(viewModel: viewModel, isPresented: $showCategorySheet)
            }
            .fullScreenCover(isPresented: $showInspiration) {
                InspirationView(viewModel: viewModel)
            }
            
            ProfileView(viewModel: viewModel)
                .tabItem { Label("æˆ‘çš„", systemImage: "person.crop.circle") }
        }
    }
}

// MARK: - è¾…åŠ©ç»„ä»¶ (FilmRollView, FilmFrameRow ç­‰)
struct FilmRollView: View {
    @ObservedObject var viewModel: AppViewModel
    @Binding var isPresented: Bool
    private let filmColor = Color(red: 0.12, green: 0.12, blue: 0.12)
    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            VStack(spacing: 0) {
                HStack {
                    Text("èƒ¶å·ç›’").font(.headline).foregroundColor(.white).padding(.leading)
                    Spacer()
                    Button(action: { isPresented = false }) {
                        Image(systemName: "xmark.circle.fill").font(.title2).foregroundColor(.white.opacity(0.6))
                    }.padding()
                }.background(filmColor)
                ScrollView {
                    VStack(spacing: 0) {
                        FilmLeaderShape().fill(filmColor).frame(height: 60).frame(maxWidth: .infinity).padding(.horizontal, 20)
                        VStack(spacing: 0) {
                            ForEach(Array(viewModel.sortedCategories.enumerated()), id: \.element.id) { index, category in
                                Button(action: {
                                    Task { await viewModel.changeCategory(to: category) }
                                    isPresented = false
                                }) {
                                    FilmFrameRow(title: category.name, index: index + 1, isSelected: viewModel.selectedCategory == category)
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }.background(filmColor)
                        Rectangle().fill(filmColor).frame(height: 50).overlay(Text("END OF ROLL").font(.caption2).foregroundColor(.gray.opacity(0.5)))
                    }.padding(.vertical, 20)
                }
            }
        }
    }
}

struct FilmFrameRow: View {
    let title: String; let index: Int; let isSelected: Bool
    var body: some View {
        HStack(spacing: 0) {
            SprocketColumn(side: .left, index: index).frame(width: 40)
            ZStack {
                RoundedRectangle(cornerRadius: 2).fill(isSelected ? Color.white : Color.black).padding(.vertical, 8)
                if isSelected {
                    VStack(spacing: 4) {
                        Text(LocalizedStringKey(title)).font(.system(size: 22, weight: .heavy, design: .rounded)).foregroundColor(.black)
                        Text("SELECTED").font(.system(size: 8, weight: .bold)).tracking(2).foregroundColor(.blue)
                    }
                } else {
                    Text(LocalizedStringKey(title)).font(.system(size: 20, weight: .bold, design: .monospaced)).foregroundColor(.white.opacity(0.8))
                }
            }
            .frame(height: 120).padding(.horizontal, 4)
            .overlay(RoundedRectangle(cornerRadius: 4).stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2).padding(.vertical, 8))
            SprocketColumn(side: .right, index: index).frame(width: 40)
        }
        .frame(maxWidth: .infinity)
        .overlay(Rectangle().fill(Color.white.opacity(0.1)).frame(height: 1), alignment: .bottom)
    }
}

struct SprocketColumn: View {
    enum Side { case left, right }
    let side: Side; let index: Int
    var body: some View {
        ZStack {
            Color(red: 0.12, green: 0.12, blue: 0.12)
            VStack(spacing: 12) {
                ForEach(0..<4) { _ in
                    RoundedRectangle(cornerRadius: 2).fill(Color(white: 0.05)).frame(width: 12, height: 18)
                        .overlay(RoundedRectangle(cornerRadius: 2).stroke(Color.white.opacity(0.1), lineWidth: 0.5))
                }
            }
            VStack {
                if side == .left {
                    Spacer(); Text("\(index)").font(.system(size: 10, weight: .bold, design: .monospaced)).foregroundColor(.yellow.opacity(0.6)).rotationEffect(.degrees(-90)).offset(x: -12); Spacer()
                } else {
                    Spacer(); Text("KINO 400").font(.system(size: 8, weight: .bold, design: .monospaced)).foregroundColor(.yellow.opacity(0.4)).rotationEffect(.degrees(90)).offset(x: 12); Spacer()
                }
            }
        }
    }
}

struct FilmLeaderShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.minX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY + 20))
        path.addLine(to: CGPoint(x: rect.midX + 20, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.minY + 20))
        path.closeSubpath(); return path
    }
}

struct SelectionButton: View {
    let title: String; let isSelected: Bool; var isExpandable: Bool = false; let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack {
                Text(LocalizedStringKey(title)).font(.system(size: 16, weight: .bold)).lineLimit(1)
                if isExpandable { Spacer(); Image(systemName: "chevron.down").font(.caption.bold()).opacity(0.6) }
            }
            .foregroundColor(isSelected ? .white : .primary)
            .padding(.vertical, 14).padding(.horizontal, 16).frame(maxWidth: .infinity)
            .background(isSelected ? Color.black : Color(UIColor.secondarySystemBackground))
            .cornerRadius(14)
            .overlay(RoundedRectangle(cornerRadius: 14).stroke(Color.black.opacity(0.05), lineWidth: 1))
            .shadow(color: isSelected ? Color.black.opacity(0.2) : .clear, radius: 8, x: 0, y: 4)
        }
        .scaleEffect(isSelected ? 1.02 : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }
}

// MARK: - ğŸŸ¢ é•¿æŒ‰é¢„è§ˆè§†å›¾ (çº¯å‡€æµ·æŠ¥ç‰ˆ)
struct MovieContextMenuPreview: View {
    let movie: Movie
    
    var body: some View {
        // åªå±•ç¤ºæµ·æŠ¥ï¼Œæ— æ–‡å­—ï¼Œæ— é®ç½©
        WebImage(url: movie.posterURL)
            .resizable()
            .indicator(.activity)
            .aspectRatio(contentMode: .fill)
            // è®¾å®šä¸€ä¸ªå›ºå®šçš„ 2:3 å°ºå¯¸ï¼Œç¡®ä¿ Context Menu å¼¹çª—å¤§å°åˆé€‚
            .frame(width: 300, height: 450)
            .clipped()
            // åŠ ä¸Šä¸€ç‚¹èƒŒæ™¯è‰²é˜²æ­¢å›¾ç‰‡åŠ è½½æ—¶å…¨é€æ˜
            .background(Color.black)
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/OnboardingView.swift
// ==========================================

//
//  OnboardingView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI

struct OnboardingView: View {
    @ObservedObject var viewModel: AppViewModel
    @State private var pendingMovie: Movie?
    @State private var stackID = UUID()
    
    var body: some View {
        ZStack {
            Color(UIColor.systemBackground).ignoresSafeArea()
            
            VStack {
                Text("å®šåˆ¶ä½ çš„å£å‘³")
                    .font(.system(size: 24, weight: .bold, design: .rounded))
                    .foregroundColor(.primary.opacity(0.8))
                    .padding(.top, 20)
                
                if !viewModel.onboardingMovies.isEmpty {
                    SwipeLegendView().padding(.top, 15).padding(.bottom, 5).transition(.opacity)
                }
                
                Spacer()
                
                ZStack {
                    if viewModel.isLoading {
                        VStack(spacing: 15) {
                            ProgressView()
                            Text("æ­£åœ¨ä¸ºä½ ç²¾é€‰...").font(.caption).foregroundColor(.gray)
                        }
                    } else if let error = viewModel.errorMessage {
                        ErrorView(errorText: error) { viewModel.retry() }
                    } else if viewModel.onboardingMovies.isEmpty {
                        VStack(spacing: 20) {
                            Image(systemName: "checkmark.circle.fill").font(.system(size: 60)).foregroundColor(.green)
                            Text("å‡†å¤‡å°±ç»ª").font(.title3).bold()
                        }
                    } else {
                        let movies = viewModel.onboardingMovies
                        let count = movies.count
                        let visibleIndices = (max(0, count - 3)..<count).map { $0 }
                        
                        ForEach(visibleIndices, id: \.self) { index in
                            let movie = movies[index]
                            let order = count - 1 - index
                            
                            DraggableCardView(
                                movie: movie,
                                isTopCard: order == 0,
                                onSwiped: { direction in handleSwipe(movie: movie, direction: direction) }
                            )
                            .id(movie.id)
                            .scaleEffect(order == 0 ? 1 : (order == 1 ? 0.95 : 0.9))
                            .offset(y: order == 0 ? 0 : (order == 1 ? 15 : 30))
                            .opacity(order > 1 ? 0 : 1)
                            .animation(.spring(response: 0.5, dampingFraction: 0.7), value: count)
                            .zIndex(Double(index))
                        }
                    }
                }
                .frame(height: 500)
                .id(stackID)
                
                Spacer()
                
                ZStack {
                    if viewModel.seenCount >= 10 {
                        VStack(spacing: 12) {
                            Button(action: { viewModel.completeOnboardingEarly() }) {
                                Text("è¿›å…¥æ¨èé¡µ").font(.headline.bold()).foregroundColor(.white).frame(maxWidth: .infinity).padding(.vertical, 16).background(LinearGradient(colors: [.blue, .purple], startPoint: .leading, endPoint: .trailing)).cornerRadius(16).shadow(color: .blue.opacity(0.4), radius: 10, x: 0, y: 5).padding(.horizontal, 40)
                            }
                            Text("å¤ªæ£’äº†ï¼æ»‘å¾—è¶Šå¤šï¼Œæ¨èè¶Šæ‡‚ä½ ").font(.caption).foregroundColor(.secondary)
                        }
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                    } else {
                        Text("è¿˜éœ€è¯„ä»· \(10 - viewModel.seenCount) éƒ¨ç”µå½±è§£é”æ¨è").font(.subheadline).foregroundColor(.secondary).padding(.bottom, 20).transition(.opacity)
                    }
                }
                .frame(height: 100)
                .padding(.bottom, 20)
                .animation(.spring(response: 0.5, dampingFraction: 0.8), value: viewModel.seenCount >= 10)
            }
            
            // ğŸŸ¢ æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨æ­¤å¤„åŠ å…¥å¤å¤æ»¤é•œ
            // æ”¾åœ¨ ZStack çš„æœ€åï¼Œç¡®ä¿å®ƒè¦†ç›–åœ¨æ‰€æœ‰å†…å®¹ä¹‹ä¸Š
            RetroFilmOverlay()
        }
        .sheet(item: $pendingMovie, onDismiss: { withAnimation(.spring()) { stackID = UUID() } }) { movie in
            RatingSheet(movie: movie, onSelect: { rating in
                viewModel.submitRating(for: movie, rating: rating)
                pendingMovie = nil
            }, onCancel: {
                pendingMovie = nil
            })
        }
    }
    
    private func handleSwipe(movie: Movie, direction: Int) {
        if direction == 0 { pendingMovie = movie }
        else { viewModel.handleQuickSwipe(movie: movie, direction: direction) }
    }
}

// DraggableCardView, RatingSheet ç­‰è¾…åŠ©ç»„ä»¶ä¿æŒä¸å˜ (å·²åœ¨æ‚¨ä¹‹å‰çš„ä»£ç ä¸­)

// ğŸŸ¢ æ ¸å¿ƒä¼˜åŒ–ï¼šDraggableCardView
struct DraggableCardView: View {
    let movie: Movie
    let isTopCard: Bool
    let onSwiped: (Int) -> Void
    
    @State private var offset: CGSize = .zero
    @State private var isDetailMode: Bool = false
    @State private var isDragging: Bool = false
    
    private let impact = UIImpactFeedbackGenerator(style: .medium)
    
    var body: some View {
        ZStack {
            MovieCardView(movie: movie, isOnboarding: true, isDetailMode: $isDetailMode)
                // å¼ºåˆ¶å›ºå®šå¤§å°ï¼Œé˜²æ­¢ iPad ä¸Šè¿‡å¤§
                .frame(width: 320, height: 480)
            
            // ğŸŸ¢ ä¼˜åŒ–ç‚¹ 1ï¼šå›¾æ ‡å§‹ç»ˆæ¸²æŸ“ï¼Œåªæ”¹å˜é€æ˜åº¦
            if isTopCard && !isDetailMode {
                OverlayIcon(name: "eye.fill", color: .blue, alignment: .topTrailing) // æ”¹å›è“è‰²ä»¥åŒ¹é… Legend
                    .opacity(offset.width < -50 ? 1 : 0) // å·¦æ»‘æ˜¾ç¤º
                
                // OverlayIcon(name: "bookmark.fill", color: .yellow, alignment: .topLeading) // å¦‚æœéœ€è¦å³æ»‘æ˜¯å¾…çœ‹
                OverlayIcon(name: "bookmark.fill", color: Color(red: 0.92, green: 0.85, blue: 0.55), alignment: .topLeading)
                    .opacity(offset.width > 50 ? 1 : 0)  // å³æ»‘æ˜¾ç¤º
                
                OverlayIcon(name: "xmark", color: .gray, alignment: .bottom)
                    .opacity(offset.height < -50 ? 1 : 0) // ä¸Šæ»‘æ˜¾ç¤º
            }
        }
        // ğŸŸ¢ ä¼˜åŒ–ç‚¹ 2ï¼šä½å›¾åˆæˆ
        .compositingGroup()
        .shadow(color: .black.opacity(0.15), radius: 10, x: 0, y: 5)
        
        // 1. ä½ç§»
        .offset(offset)
        // 2. æ—‹è½¬
        .rotationEffect(.degrees(Double(offset.width / 15)))
        // 3. ç¼©æ”¾ (æèµ·æ•ˆæœ)
        .scaleEffect(isDragging ? 1.02 : 1.0)
        // 4. æ‰‹åŠ¿
        .gesture(
            DragGesture()
                .onChanged { gesture in
                    guard isTopCard, !isDetailMode else { return }
                    
                    // ğŸŸ¢ ä¼˜åŒ–ç‚¹ 3ï¼šå¼ºåˆ¶å…³é—­éšå¼åŠ¨ç”»
                    var transaction = Transaction()
                    transaction.animation = nil
                    withTransaction(transaction) {
                        offset = gesture.translation
                    }
                    
                    // é˜²æŠ–å¤„ç†ç¼©æ”¾çŠ¶æ€
                    if !isDragging {
                        withAnimation(.easeInOut(duration: 0.1)) {
                            isDragging = true
                        }
                    }
                }
                .onEnded { _ in
                    guard isTopCard, !isDetailMode else { return }
                    
                    // æ¢å¤ç¼©æ”¾
                    withAnimation(.easeInOut(duration: 0.2)) {
                        isDragging = false
                    }
                    
                    handleSwipeEnd()
                }
        )
    }
    
    private func handleSwipeEnd() {
        let threshold: CGFloat = 120
        
        // æ¾æ‰‹æ—¶åº”ç”¨å¹³æ»‘åŠ¨ç”»
        if offset.width < -threshold {
            swipeOut(x: -600, y: offset.height, dir: 0)
        } else if offset.width > threshold {
            swipeOut(x: 600, y: offset.height, dir: 2)
        } else if offset.height < -threshold {
            swipeOut(x: offset.width, y: -800, dir: 1)
        } else {
            // å›å¼¹å¤ä½
            withAnimation(.spring(response: 0.4, dampingFraction: 0.6, blendDuration: 0)) {
                offset = .zero
            }
        }
    }
    
    private func swipeOut(x: CGFloat, y: CGFloat, dir: Int) {
        impact.impactOccurred()
        withAnimation(.easeIn(duration: 0.2)) {
            offset = CGSize(width: x, height: y)
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            onSwiped(dir)
        }
    }
}

struct OverlayIcon: View {
    let name: String; let color: Color; let alignment: Alignment
    var body: some View {
        ZStack { Color.clear; Image(systemName: name).font(.system(size: 80)).foregroundColor(color).shadow(radius: 2).padding(40) }
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: alignment)
            .animation(.easeInOut(duration: 0.2), value: 1)
    }
}

struct RatingSheet: View {
    let movie: Movie
    let onSelect: (AppViewModel.RatingType) -> Void
    let onCancel: () -> Void
    @Environment(\.presentationMode) var presentationMode
    
    var body: some View {
        VStack(spacing: 25) {
            Capsule().fill(Color.gray.opacity(0.3)).frame(width: 40, height: 5).padding(.top, 10)
            VStack(spacing: 8) {
                Text("è¯„ä»·è¿™éƒ¨ç”µå½±").font(.headline)
                Text(movie.title).font(.subheadline).foregroundColor(.secondary).multilineTextAlignment(.center).padding(.horizontal)
            }
            HStack(spacing: 25) {
                OnboardingRatingBtn(icon: "heart.fill", text: "å–œæ¬¢", color: .red) { onSelect(.like) }
                OnboardingRatingBtn(icon: "face.smiling.fill", text: "ä¸€èˆ¬", color: .blue) { onSelect(.neutral) }
                OnboardingRatingBtn(icon: "hand.thumbsdown.fill", text: "ä¸å–œæ¬¢", color: .gray) { onSelect(.dislike) }
            }
            Button("æˆ‘ç‚¹é”™äº† (æ²¡çœ‹è¿‡)") { onCancel(); presentationMode.wrappedValue.dismiss() }
            .font(.footnote).foregroundColor(.secondary).padding(.top, 10)
            Spacer()
        }
        .padding().presentationDetents([.height(300)]).presentationDragIndicator(.hidden)
    }
}

struct OnboardingRatingBtn: View {
    let icon: String; let text: String; let color: Color; let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 10) { Image(systemName: icon).font(.system(size: 30)); Text(LocalizedStringKey(text)).font(.caption.bold()) }
            .foregroundColor(color).frame(width: 85, height: 85).background(color.opacity(0.1)).cornerRadius(20)
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTaste/ErrorView.swift
// ==========================================

//
//  ErrorView.swift
//  KinoTaste
//
//  Created by Boxiang Shan on 2026/1/4.
//
import SwiftUI

struct ErrorView: View {
    let errorText: String
    let retryAction: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "wifi.exclamationmark")
                .font(.system(size: 60))
                .foregroundColor(.gray)
            
            // "å“å‘€ï¼Œå‡ºé”™äº†" ä¼šè‡ªåŠ¨åŒ¹é… Strings æ–‡ä»¶
            Text("å“å‘€ï¼Œå‡ºé”™äº†")
                .font(.title2).bold()
            
            // ğŸŸ¢ å¼ºåˆ¶æœ¬åœ°åŒ–ï¼šç¡®ä¿ä¼ å…¥çš„é”™è¯¯ä¿¡æ¯ (å¦‚ "ç½‘ç»œä¸ä½³") èƒ½å˜æˆç¹ä½“
            Text(LocalizedStringKey(errorText))
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            
            Button(action: retryAction) {
                Text("é‡è¯•")
                    .bold()
                    .foregroundColor(.white)
                    .padding(.vertical, 12)
                    .padding(.horizontal, 30)
                    .background(Color.black)
                    .cornerRadius(25)
            }
        }
        .padding()
        .background(Color.white)
    }
}


// ==========================================
// FILE PATH: ./KinoTasteUITests/KinoTasteUITests.swift
// ==========================================

//
//  KinoTasteUITests.swift
//  KinoTasteUITests
//
//  Created by Boxiang Shan on 2026/1/4.
//

import XCTest

final class KinoTasteUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests itâ€™s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}


// ==========================================
// FILE PATH: ./KinoTasteUITests/KinoTasteUITestsLaunchTests.swift
// ==========================================

//
//  KinoTasteUITestsLaunchTests.swift
//  KinoTasteUITests
//
//  Created by Boxiang Shan on 2026/1/4.
//

import XCTest

final class KinoTasteUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
